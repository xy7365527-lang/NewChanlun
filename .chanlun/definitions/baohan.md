# K线包含处理（Baohan / Inclusion Merge）

**版本**: v1.2
**状态**: 生成态
**最后更新**: 2026-02-15
**变更**:
- v1.0 初版
- v1.1 尝试用等价性证明结算方向判定问题（已回退）
- v1.2 回退为生成态，增加原文谱系，重新定位方向判定差异
**原文依据**: 博文第62课、第65课、编纂版 §四

---

## 原文谱系

包含处理概念在缠师108课中的演化：

### 第62课 (2007-06-30) — 首次引入

> "相邻两K线可以出现包含关系，也就是一K线的高低点全在另一K线的范围里"

- **包含关系**：首次定义，纯几何概念
- **合并规则**：向上取 max(high), max(low)；向下取 min(high), min(low)
- **方向判定**：未形式化，只用"在向上时"/"当向下时"的表述
- **顺序原则**：未在此课明确提出
- **特点**：操作性描述，假设读者"看图就知道"什么是向上向下

### 第65课 (2007-07-24) — 形式化补完（关键课）

> "假设，第n根K线满足第n根与第n+1根的包含关系，而第n根与第n-1根不是包含关系，那么如果gn>=gn-1，那么称第n-1、n、n+1根K线是向上的；如果dn<=dn-1，那么称第n-1、n、n+1根K线是向下的。"

- **方向判定形式化**：单条件，`gn>=gn-1 → 向上`，`dn<=dn-1 → 向下`
- **等号问题**：原文用 `>=` 和 `<=`，有注释"应去掉等号"（可能是编者注，非缠师原话）
- **缠师自问自答（L26）**：

  > "有人可能又要问，如果gn<gn-1且dn>dn-1，算什么？那就是一种包含关系，这就违反了前面第n根与第n-1根不是包含关系的假设。同样道理，gn>=gn-1与dn<=dn-1不可能同时成立。"

  缠师在此明确指出：交叉情况（高降低升）本身就是包含关系。这是从包含的定义出发的推论，不是方向判定的规则。
- **顺序原则**：结合律、不遵守传递律、先左后右
- **唯一性宣言**：处理结果"客观、唯一、不以任何人的意志为转移"

### 第67课 (2007-08-02) — 概念迁移

- 包含关系从K线扩展到**特征序列元素**
- 特征序列的包含处理规则同K线
- "标准特征序列" = 经过包含处理后的特征序列

### 第71课 (2007-08-23) — 作用域限制

- **关键约束**：特征序列元素的包含关系，前提是元素在**同一特征序列**里
- 不同特征序列之间的元素讨论包含关系无意义
- 转折点前后两元素不存在包含关系（不同性质）
- 转折点后的分型元素可以应用包含关系（同一性质）

### 第77课 (2007-09-13) — 操作巩固

- "按定义，只要把包含关系搞清楚，相信连孔男人都应该能描红一番"
- 强调先做包含处理和结合律处理，再标记分型

### 第82课 (2007-09-19) — 市场心理扩展

- 包含关系的市场含义：**犹豫、不确定的观望**
- 完全无包含的分型 = 市场双方直截了当
- "直接把阳线以长阴线吃掉"是最坏的包含
- 从分型力度角度分析包含的不同模式

### 谱系小结

| 阶段 | 课号 | 性质 |
|------|------|------|
| 直觉引入 | 62 | 告诉你怎么做 |
| 形式化 | 65 | 告诉你为什么这么做 |
| 概念迁移 | 67 | 同样的定义用到更高层 |
| 作用域 | 71 | 什么时候不能用 |
| 巩固 | 77 | 再次确认操作流程 |
| 深化 | 82 | 从市场心理角度理解包含 |

---

## 定义

### 包含关系（自足定义）

两根K线存在包含关系，当且仅当一根K线的高低点区间完全在另一根K线范围内。

形式化：K1 包含 K2 当 `K1.high >= K2.high AND K1.low <= K2.low`。
反之 K2 包含 K1 当 `K2.high >= K1.high AND K2.low <= K1.low`。
任一成立即为"存在包含关系"。

> 包含关系是纯几何定义，不依赖方向、不依赖时间顺序。两个区间的包含关系是它们之间固有的。

### 合并方向

当相邻两根K线存在包含关系时，需要确定合并方向。方向由此前最近一对**无包含关系**的相邻K线决定：

**原文（第65课 L24）**：单条件
- `gn >= gn-1` → 向上（注：有编者注建议去掉等号）
- `dn <= dn-1` → 向下

**代码实现**：双条件
- `high_i > high_{i-1} AND low_i > low_{i-1}` → dir = UP
- `high_i < high_{i-1} AND low_i < low_{i-1}` → dir = DOWN
- 否则 dir 保持不变

**差异记录**（不急于结算）：
- 原文用单条件形式表述，缠师在第65课 L26 从包含的定义出发解释了为什么交叉不可能
- 代码用双条件，是一种防御性实现
- 两者在非包含前提下数学结果相同，但**概念路径不同**：原文从"包含的定义→推论交叉不可能→所以单条件够用"出发；代码直接检查双条件
- **等号问题**也仍然开放：原文用 `>=`/`<=`，代码用 `>`/`<`

**初始方向**：dir 初始为 None。遇到包含关系时 dir 仍为 None → 默认按 UP 合并。

### 合并规则

- **向上合并**：`new_high = max(h1, h2)`, `new_low = max(l1, l2)`
- **向下合并**：`new_high = min(h1, h2)`, `new_low = min(l1, l2)`
- **OHLC 工程处理**：`open = 左K.open`, `close = 右K.close`

### 顺序原则

**先左后右**递推（第65课 L20）：
1. 从第1根K线开始，依次检查后续K线
2. 若当前 merged bar 与新K线存在包含关系 → 按当前方向合并
3. 否则 → 更新 dir，新K线作为新的 merged bar
4. 完成后序列无任何相邻包含关系

**性质**（第65课 L20）：
- 包含处理遵守结合律
- 不遵守传递律（A 包含 B 且 B 包含 C，不代表 A 包含 C）

## 输出

- `df_merged`: 包含处理后的K线序列（无相邻包含）
- `merged_to_raw: list[tuple[int, int]]`: 每根 merged bar 对应原始K线的位置范围（闭区间）

`merged_to_raw` 是新笔间距计算的关键数据来源。

## 当前实现

- **文件**: `src/newchan/a_inclusion.py :: merge_inclusion`
- **方向判定**: 双条件
- **初始方向**: None → 默认按 UP 合并
- **输出**: `(df_merged, merged_to_raw)`

## 边界条件

- 空输入 → 返回空 DataFrame 和空列表
- 单根K线 → 原样返回，`merged_to_raw = [(0, 0)]`
- 相邻K线 high 或 low 恰好相等 → 视为包含（`>=`，非严格大于）
- 连续多根包含 → 持续合并到同一个 merged bar 中

## 未结算问题

1. **方向判定：单条件 vs 双条件**。原文（65课）用单条件，代码用双条件。数学结果相同但概念路径不同。需要决定：是否将代码改为单条件以贴合原文语义，还是保留双条件作为防御实现？
2. **等号问题**：原文用 `>=`/`<=`，代码用 `>`/`<`。编者注"应去掉等号"的来源和理由不明。`>=` 包含判定下等号场景不影响方向判定结果，但需要确认这个编者注是否有缠师本人的依据。
3. **初始方向 None → UP 的合理性**。原文未明确给出初始方向的处理方式。默认 UP 是工程选择，尚无原文依据。

## 谱系引用

- 间接关联 001：包含处理的正确性影响分型识别 → 影响笔划分 → 影响退化段
- 间接关联新笔：`merged_to_raw` 是新笔间距计算的数据来源

## 影响声明

包含处理是整个管线的第一步。所有后续概念（分型、笔、线段、中枢、走势类型）建立在包含处理后的序列上。`merged_to_raw` 的正确性直接影响新笔间距计算。
