# 分型（Fenxing / Fractal）

**版本**: v1.0
**状态**: 已结算
**最后更新**: 2026-02-15
**原文依据**: 编纂版 §五；博文第62课

---

## 定义

分型是包含处理后K线序列上的局部极值结构，由三根相邻K线构成。

### 顶分型（双条件）

三根相邻K线 K[i-1], K[i], K[i+1] 中，第二根 K[i] 同时满足：
- K[i].high > K[i-1].high **且** K[i].high > K[i+1].high
- K[i].low > K[i-1].low **且** K[i].low > K[i+1].low

极值价 = K[i].high

### 底分型（双条件）

三根相邻K线 K[i-1], K[i], K[i+1] 中，第二根 K[i] 同时满足：
- K[i].low < K[i-1].low **且** K[i].low < K[i+1].low
- K[i].high < K[i-1].high **且** K[i].high < K[i+1].high

极值价 = K[i].low

### 为什么是双条件

只满足 high 条件但 low 不满足（或反之）不构成分型。这不是"加强版"——这是定义本身。包含处理保证了相邻K线不存在包含关系，所以双条件在包含处理后的序列上是自然的。

## 前置条件

分型**必须**在包含处理后的K线序列（MergedBar）上判定。原始K线可能存在包含关系，在原始序列上判定分型是错误的。

## 基本结论

- 没有顶分型 → 没有顶 → 没有下降笔的起点
- 没有底分型 → 没有底 → 没有上升笔的起点
- 首尾K线不可能是分型（需要左右邻居）
- 至少需要3根MergedBar才可能出现分型
- 严格大于（不含等于）：包含处理后理论上不会出现等值，但若出现，不构成分型

## 当前实现

- **文件**: `src/newchan/a_fractal.py :: fractals_from_merged`
- **数据结构**: `Fractal` dataclass（frozen, slots）
- **字段**: idx（中心bar的iloc位置）, kind（top/bottom）, price（极值价）
- **对齐状态**: 实现与定义完全对齐，无口径分歧

## 边界条件

- 恰好等值时不成分型（严格不等式）
- 只有3根bar的序列最多产出1个分型（位于 idx=1）
- 分型识别不做去重/过滤——留给笔构造步骤

## 接口缺口（影响新笔实现）

Fractal 当前只存储 `idx`（中心bar位置）和 `price`（极值价）。不存储组成分型的三根bar各自的位置信息。

新笔间距定义需要的是"顶分型最高K线的位置"和"底分型最低K线的位置"。对于双条件分型：
- **顶分型最高K线** = 中心bar K[idx]（因为 K[idx].high 是三者最高）→ 位置就是 idx
- **底分型最低K线** = 中心bar K[idx]（因为 K[idx].low 是三者最低）→ 位置就是 idx

所以在双条件分型下，极值K线就是中心bar。**新笔间距可以直接用 `idx` 计算，不需要额外字段。**

但需要注意：新笔测量的是"不含这两根K线"之间的bar数，即 `cand.idx - start.idx - 1 >= 3`，等价于 `cand.idx - start.idx >= 4`。

> 这意味着：如果双条件分型成立，**新笔和旧笔的间距阈值可能是相同的（gap >= 4）**，差异只在测量基准的语义而非数值。这需要实证验证。

## 谱系引用

- 无直接关联的生成态矛盾
- 间接关联 001：分型定义影响笔定义，笔定义影响退化段

## 影响声明

分型是整个系统的最底层概念（K线之上第一层）。分型定义变更会级联影响笔、线段、中枢、走势类型。当前定义已结算——双条件无争议，代码对齐。
