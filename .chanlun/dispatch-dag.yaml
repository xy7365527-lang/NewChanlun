# dispatch-dag.yaml
# 声明式工位分派规范（DAG 拓扑版 + 事件驱动 skill 架构）
#
# 设计原则：
#   1. 线性 dispatch-spec → 严格 DAG（068号：偏序集，非连续流形）
#   2. 结构能力 = skill（事件驱动），不是 teammate（075号）
#   3. 结晶工位 = 唯一合法汇点（Terminal Sink）
#   4. 子蜂群分形模板实例化（069号：递归拓扑异步自指化）
#   5. Lead 是 DAG 解释器，不是决策者（033号）
#   6. dispatch-dag 定义"事件→skill 映射"，不是"必须 spawn 的 agent 列表"（075号）
#
# 修改路径：/ritual 推荐流程（073号：仪式是推荐流程，不是强制门控）
# 修改提案者：meta-observer → gemini-challenger 高阶审查（069号提案模式）

version: "3.0"
provenance: "[新缠论]"
genealogy_ref: "072, 068, 069, 075-structural-to-skill"

# ═══════════════════════════════════════════════════════════════
# 1. 谱系坐标（每个工位在谱系空间中的位置）
# ═══════════════════════════════════════════════════════════════
genealogical_coordinates:
  genealogist:
    origin: "012-genealogy-is-discovery-engine"
    domain: "谱系维护"
    negation_source: "张力碰撞（内在否定）"
  quality-guard:
    origin: "033-declarative-dispatch-spec"
    domain: "质量守卫"
    negation_source: "结果包不合格（内在否定）"
  meta-observer:
    origin: "033-declarative-dispatch-spec"
    domain: "二阶反馈"
    negation_source: "元规则自身矛盾（内在否定）"
  source-auditor:
    origin: "004-provenance-framework"
    domain: "溯源审计"
    negation_source: "权威链断裂（内在否定）"
  topology-manager:
    origin: "019d-tension-depth-limit"
    domain: "拓扑分析"
    negation_source: "区间套收敛信号（内在否定）"
  gemini-challenger:
    origin: "030a-heterogeneous-negation, 041-orchestrator-proxy"
    domain: "异质否定"
    negation_source: "异质质询产出（外部对象否定）"
  claude-challenger:
    origin: "062-gemini-re-challenge"
    domain: "反向质询（癔症话语）"
    negation_source: "不可消化点（外部对象否定）"
  skill-crystallizer:
    origin: "043-self-growing-loop"
    domain: "知识结晶"
    negation_source: "模式达标（内在否定——候选态→结晶态）"

# ═══════════════════════════════════════════════════════════════
# 2. 事件→Skill 映射（075号：结构能力从 teammate 转为事件驱动 skill）
# ═══════════════════════════════════════════════════════════════
event_skill_map:
  # 每个 skill 由事件触发，不再作为 teammate spawn
  # agent 文件保留为 skill 的指令源（读取后按指令执行）
  - id: genealogist
    skill_type: structural
    agent: ".claude/agents/genealogist.md"
    purpose: "谱系写入、张力检查、回溯扫描、结晶检测与执行"
    triggers:
      - event: task_complete
        description: "业务工位完成时触发谱系检查"
      - event: command
        pattern: "/escalate"
        description: "矛盾上浮时写入 pending 谱系"
      - event: session_end
        description: "session 结束时执行回溯扫描"

  - id: quality-guard
    skill_type: structural
    agent: ".claude/agents/quality-guard.md"
    purpose: "结果包检查、代码违规扫描"
    triggers:
      - event: file_write
        pattern: ".chanlun/genealogy/**"
        description: "谱系写入后检查结果包"
      - event: file_write
        pattern: "src/**"
        description: "代码写入后扫描违规"
      - event: command
        pattern: "/inquire"
        description: "四步质询序列"

  - id: meta-observer
    skill_type: structural
    agent: ".claude/agents/meta-observer.md"
    purpose: "二阶反馈回路、元编排进化、dispatch-dag 修改提案"
    triggers:
      - event: session_end
        description: "session 结束时执行二阶观察"
      - event: swarm_cycle_end
        description: "蜂群循环结束时检查元规则一致性"

  - id: code-verifier
    skill_type: structural
    agent: ".claude/agents/code-verifier.md"
    purpose: "代码验证——pytest运行、import检查、构建验证"
    triggers:
      - event: file_write
        pattern: "src/**/*.py"
        description: "Python 代码变更后验证"
      - event: file_write
        pattern: "tests/**/*.py"
        description: "测试文件变更后运行"

  - id: skill-crystallizer
    skill_type: terminal_sink
    agent: ".claude/agents/skill-crystallizer.md"
    purpose: "pattern-buffer 达标模式结晶为 skill（043号谱系）"
    triggers:
      - event: pattern_buffer_ready
        condition: "status=candidate 且 frequency >= promotion_threshold"
        description: "模式达标时触发结晶"
    invariant: "所有经过 quality-guard 验证的结晶候选必须且只能流向此 skill"

  - id: gemini-challenger
    skill_type: conditional
    agent: ".claude/agents/gemini-challenger.md"
    purpose: "异质否定源 + 编排者代理（030a/041号谱系）"
    triggers:
      - event: command
        pattern: "/challenge"
        description: "显式质询触发"
      - event: file_change
        pattern: "spec/theorems/*"
        mode: "verify"
        description: "定理文件变更时验证"
      - event: escalate_choice
        description: "选择/语法记录类决断路由到 Gemini decide"

  - id: claude-challenger
    skill_type: conditional
    agent: ".claude/agents/claude-challenger.md"
    purpose: "反向质询——对 Gemini 产出进行再质询，指出不可消化点"
    triggers:
      - event: re_challenge
        description: "Gemini 产出需要被再质询时"
      - event: stale_generative
        condition: "同质质询已完成 2 轮以上但定义仍处于生成态"

  - id: source-auditor
    skill_type: conditional
    agent: ".claude/agents/source-auditor.md"
    purpose: "溯源标签验证、引用准确性检查"
    triggers:
      - event: file_write
        pattern: "docs/**"
        description: "文档写入时检查溯源标签"

  - id: topology-manager
    skill_type: conditional
    agent: ".claude/agents/topology-manager.md"
    purpose: "谱系拓扑分析、hub 节点监控、蜂群收缩信号"
    triggers:
      - event: genealogy_count_threshold
        condition: "谱系总数 > 30 或 pending 谱系 > 5"

# ═══════════════════════════════════════════════════════════════
# 2b. 节点声明（仅保留任务节点模板和系统节点）
# ═══════════════════════════════════════════════════════════════
nodes:

  # --- 任务节点模板（运行时动态实例化） ---
  task_template:
    type: worker
    derivation: "session.interruption_points + CLAUDE.md.objectives"
    spawn_phase: "post-structural-spawn"
    # DAG 约束：任务节点的输入/输出边必须连接支配节点
    input_constraint: "requires_dominator_edge"
    output_constraint: "requires_dominator_edge"
    # spawn 三基因（073a号谱系：每个衍生节点必须携带）
    required_genes:
      - id: topo_address
        description: "当前节点在分形树中的拓扑坐标（如 v13-swarm/gene-writer）"
        format: "{team_name}/{agent_name}"
        enforcement: "spawn 时 Lead 必须在 prompt 中注入"
      - id: depth_budget
        description: "剩余递归深度或 token 预算，防止无限增殖"
        format: "integer >= 0"
        enforcement: "depth_budget=0 时禁止 spawn 子节点"
      - id: parent_callback
        description: "父节点等待结果的标识符"
        format: "{team_name}/{recipient_name}"
        enforcement: "完成后必须通过 SendMessage 向 parent_callback 汇报"
    rules:
      - "每个独立中断点 = 一个工位（并行默认）"
      - "有数据依赖的中断点 = 串行链"
      - "Lead 不自行执行任务，只分派和汇总"
      - "无简单任务豁免——≥1 个任务即拉蜂群"  # G8, 055号
      - "蜂群递归是默认执行模式，不是复杂度触发的优化——任何多目标任务默认并行 spawn"  # 055号
      - "子工位为局部作用域（不修改全局 hook/谱系/定义），递归深度由 topology-manager 收敛信号终止（020号背驰+分型），无人为硬限制"
      - "020号（背驰+分型）是递归的终止/结算条件，不是启动条件"  # 020号

  # --- 系统/虚拟节点（外部系统，不受 DAG 拓扑约束） ---
  system_nodes:
    - id: ceremony
      type: source
      description: "Swarm₀ 入口点，DAG 的唯一源节点"
    - id: system
      type: virtual
      description: "外部系统事件源（文件变更、注解检测等），不是 agent"
    - id: manifest_guard
      type: virtual
      description: "manifest 注册检查（hook 实现），不是 agent"
    - id: swarm_manager
      type: virtual
      description: "蜂群递归 spawn 管理器（Lead 角色），不是独立 agent"
    - id: pattern_detector
      type: virtual
      description: "模式检测（post-session-pattern-detect hook），不是 agent"
    - id: build_resolver
      type: virtual
      description: "构建错误修复（build-error-resolver agent），按需激活"
    - id: fallback
      type: virtual
      description: "降级路径（Gemini 不可用时的 pending 队列），不是 agent"

# ═══════════════════════════════════════════════════════════════
# ═══════════════════════════════════════════════════════════════
edges:
  # --- skill 间的数据流边（事件驱动，不再是 spawn 边） ---
  skill_flow_edges:
    # 谱系写入 → 质量检查（谱系产出需要质量检查）
    - from: genealogist
      to: quality-guard
      type: genealogy_validated
      trigger: "genealogist skill 完成后自动触发 quality-guard skill"

    # 质量通过 → 结晶汇点（唯一合法路径）
    - from: quality-guard
      to: skill-crystallizer
      type: validation_pass
      trigger: "quality-guard 通过且存在结晶候选时触发"

    # 元观察者 → 自身（二阶反馈回路）
    - from: meta-observer
      to: meta-observer
      type: self_observation
      description: "构成性矛盾：观察者与被观察系统不可分离（020号）"

    # 元观察者 → gemini-challenger（提案审查路径，069号）
    - from: meta-observer
      to: gemini-challenger
      type: proposal_review
      condition: "dispatch-dag/核心定义/已结算谱系修改提案"
      trigger: "meta-observer 产出提案时触发 gemini-challenger verify"

  # --- 任务工位的边约束（模板，运行时实例化） ---
  task_edge_constraints:
    # 硬约束：所有任务产出必须经过 quality-guard skill
    - constraint: "quality_gate"
      rule: "任何 task_node 的产出在提交前必须触发 quality-guard skill"
      enforcement: "file_write hook 自动触发"

    - constraint: "concept_discovery_routing"
      rule: "任何 task_node 的概念发现（新定义/新谱系）必须触发 genealogist skill"
      enforcement: "task_node 不可直接写入 .chanlun/genealogy/ 或 .chanlun/definitions/（由 hook 拦截并触发 skill）"

    - constraint: "meta_observation"
      rule: "meta-observer skill 在 session_end 时自动执行二阶观察"
      enforcement: "session_end 事件触发"

  # --- 事件触发边（从 orchestration_protocol 迁移） ---
  event_edges:
    - event: file_change
      pattern: "spec/theorems/*"
      activates_edge: "task_node → gemini-challenger"
      mode: "verify"
      priority: high

    - event: file_change
      pattern: "docs/chan_spec.md"
      activates_edge: "task_node → genealogist"
      action: "lineage_consistency_check"
      priority: high

    - event: file_create
      pattern: "**/*"
      activates_edge: "system → manifest_guard"
      action: "check_manifest_registration"
      priority: high

    - event: annotation
      pattern: "@proof-required"  # 规则定义：检测到此注解时路由到 gemini-challenger（非待验证标签）
      activates_edge: "task_node → gemini-challenger"
      mode: "challenge --math"
      priority: low_async

    - event: task_queue
      condition: "independent_tasks >= 2"
      activates_edge: "system → swarm_manager"
      action: "spawn_recursive_swarm"
      priority: high

    - event: session_start
      activates_edge: "system → ceremony"
      priority: critical

    - event: session_end
      activates_edge: "system → pattern_detector"
      action: "post_session_pattern_detect"
      priority: low_async

    - event: tool_error
      pattern: "gemini_api_*"
      activates_edge: "system → fallback"
      action: "fallback_local_rules"
      priority: critical

    - event: build_failure
      condition: "consecutive_failures >= 3"
      activates_edge: "system → build_resolver"
      action: "auto_fix_build"
      priority: medium

    - event: command
      pattern: "/inquire"
      activates_edge: "task_node → quality-guard"
      action: "four_step_inquiry"
      description: "四步质询序列（定义回溯→反例检验→边界条件→谱系比对）"
      priority: high

    - event: command
      pattern: "/escalate"
      activates_edge: "task_node → genealogist"
      action: "write_pending_genealogy"
      description: "矛盾上浮：写入 pending 谱系，选择/语法记录类经 orchestrator_proxy 路由到 Gemini decide"
      priority: critical

# ═══════════════════════════════════════════════════════════════
# 4. 编排者代理（041号谱系）
# ═══════════════════════════════════════════════════════════════
orchestrator_proxy:
  enabled: true
  genealogy_ref: "041-orchestrator-proxy"
  agent: ".claude/agents/gemini-challenger.md"
  mode: "decide"
  routes:
    - type: "选择"
      action: "调用 Gemini decide()，决策直接执行"
    - type: "语法记录"
      action: "调用 Gemini decide()，辨认结果写入谱系"
  human_override: "INTERRUPT — 人类编排者可随时覆盖"
  fallback: "Gemini 不可用时，写入 pending 等待人类"

# ═══════════════════════════════════════════════════════════════
# 5. 子蜂群分形模板（069号谱系）
# ═══════════════════════════════════════════════════════════════
fractal_template:
  genealogy_ref: "037-recursive-swarm-fractal, 069-recursive-topology-async-self-referential-swarm, 075-structural-to-skill"
  description: "子蜂群实例化时，skill 全局可用（事件驱动），无需继承结构 teammates"

  # 075号：skill 是全局的，子蜂群不再 spawn 结构 teammates
  # 所有 event_skill_map 中的 skill 对任意层级蜂群自动可用
  inherited_skills: "all"  # 子蜂群继承父蜂群的全部 skill（通过事件触发，无需 spawn）

  # 父子接口：子蜂群产出通过事件触发父蜂群 skill
  parent_interface:
    output_events:
      - event: "child_task_complete"
        triggers: ["quality-guard", "genealogist"]
        description: "子蜂群任务完成时触发父蜂群的质量检查和谱系检查"
      - event: "child_meta_feedback"
        triggers: ["meta-observer"]
        description: "子蜂群元观察上交父蜂群二阶反馈"

  # 递归规则（从 dispatch-spec 迁移）
  recursion_rules:
    - "任何 teammate 面对 ≥1 个可分解子任务时，可 spawn 子 teammates"
    - "子 teammates 继承完整的 spawn 能力（无限递归）"
    - "递归深度无人为限制，由 topology-manager 的区间套收敛信号自然终止"
    - "父 teammate 对子 teammates 负路由责任"
    - "结构工位默认扁平——裁判不参与走势。例外：结构工位自身任务需分解时允许 spawn 同类型子工位（受限递归），不允许 spawn 任务工位"
  visibility: "所有 teammates（含任意深度的子 teammates）在同一 task list 中可见"
  cost_control: "topology-manager 监控总 teammate 数量，通过区间套收敛信号判断收缩时机"

# ═══════════════════════════════════════════════════════════════
# 6. Ceremony 序列（DAG 格式，从 dispatch-spec 直接迁移）
# ═══════════════════════════════════════════════════════════════
ceremony_sequence:
  cold_start:
    output_policy: "仅 recurse 节点或 terminate_condition 产出面向用户的输出"
    nodes:
      - id: "scan-definitions"
        action: "扫描 .chanlun/definitions/*.md 版本和状态"
        depends_on: []
      - id: "scan-genealogy"
        action: "扫描 .chanlun/genealogy/{pending,settled}/ 统计"
        depends_on: []
      - id: "scan-methodology"
        action: "读取 CLAUDE.md + dispatch-dag.yaml"
        depends_on: []
      - id: "scan-skills"
        action: "扫描 .chanlun/manifest.yaml skill 时间戳"
        depends_on: []
        genealogy_ref: "051-runtime-connection-design"
      - id: "derive-work"
        action: "从目标+谱系状态+代码库扫描推导任务工位"
        depends_on: ["scan-definitions", "scan-genealogy", "scan-methodology", "scan-skills"]
        scan_sources:
          - "CLAUDE.md 目标"
          - "pending 谱系（生成态矛盾）"
          - "测试失败（新增 vs pre-existing）"
          - "谱系下游行动未执行（spec-execution gap）"
          - "pattern-buffer 达标模式"
        no_work_fallback: "扫描 TODO/覆盖率/spec合规/谱系张力，产出至少一个工位"
      - id: "load-skills"
        action: "从 event_skill_map 加载可用 skill 列表（不 spawn，仅注册）"
        depends_on: ["derive-work"]
      - id: "spawn-tasks"
        action: "并行 spawn 业务工位（skill 由事件自动触发，无需 spawn）"
        depends_on: ["load-skills"]
      - id: "divine-madness"
        action: "Lead 权限剥夺（032号谱系）"
        depends_on: ["spawn-tasks"]
      - id: "recurse"
        action: "输出 '→ 接下来：[action]' 紧跟 tool 调用"
        depends_on: ["divine-madness"]
    terminate_condition:
      trigger: "derive-work 扫描全部来源后仍无工位可派生"
      action: "输出 '[020号反转] 无新区分可产出——系统干净终止' → 停止"

  warm_start:
    output_policy: "仅 recurse 节点或 terminate_condition 产出面向用户的输出"
    nodes:
      - id: "locate-session"
        action: "定位最新 .chanlun/sessions/*.md"
        depends_on: []
      - id: "scan-definitions"
        action: "扫描当前 definitions/ 版本"
        depends_on: []
      - id: "scan-genealogy"
        action: "扫描当前 genealogy/ 状态"
        depends_on: []
      - id: "version-diff"
        action: "对比 session vs 当前定义版本（内部，不输出报告）"
        depends_on: ["locate-session", "scan-definitions"]
      - id: "genealogy-diff"
        action: "对比 session vs 当前谱系状态（内部，不输出报告）"
        depends_on: ["locate-session", "scan-genealogy"]
      - id: "derive-work"
        action: "从中断点+差异+代码库扫描推导任务工位"
        depends_on: ["version-diff", "genealogy-diff"]
        scan_sources:
          - "session 中断点"
          - "version-diff 中的升级/新增项"
          - "genealogy-diff 中的新 pending"
          - "测试失败（新增 vs pre-existing）"
          - "谱系下游行动未执行（spec-execution gap）"
          - "pattern-buffer 达标模式"
        no_work_fallback: "扫描 TODO/覆盖率/spec合规/谱系张力，产出至少一个工位"
      - id: "spawn-tasks"
        action: "并行 spawn 业务工位（skill 由事件自动触发，无需 spawn）"
        depends_on: ["derive-work"]
      - id: "divine-madness"
        action: "Lead 权限剥夺（032号谱系）"
        depends_on: ["spawn-tasks"]
      - id: "recurse"
        action: "输出 '→ 接下来：[action]' 紧跟 tool 调用"
        depends_on: ["divine-madness"]
    terminate_condition:
      trigger: "derive-work 扫描全部来源后仍无工位可派生"
      action: "输出 '[020号反转] 无新区分可产出——系统干净终止' → 停止"

# ═══════════════════════════════════════════════════════════════
# 7. DAG 验证规则
# ═══════════════════════════════════════════════════════════════
validation:
  # --- DAG 拓扑不变量 ---
  dag_invariants:
    - id: "quality_gate_reachability"
      check: "所有 task_node 的产出必须经过 quality-guard skill（通过事件触发）"
      enforcement: "file_write hook 自动触发 quality-guard"
      on_fail: "警告——hook 未配置"

    - id: "single_terminal_sink"
      check: "当 skill-crystallizer 激活时，它是唯一 terminal_sink；未激活时，quality-guard 为事实汇点"
      on_fail: "阻塞——多汇点违反结晶唯一性"

    - id: "no_cycles"
      check: "除 meta-observer 自环外，skill 流图无环"
      exception: "meta-observer → meta-observer 自环是构成性矛盾（020号），合法"
      on_fail: "阻塞——环路违反 DAG 定义"

  # --- 运行时验证（075号更新：从 dominator spawn 检查改为 skill 可用性检查） ---
  post_ceremony:
    - check: "skills_registered"
      condition: "event_skill_map 中所有 structural skill 的 agent 文件存在"
      on_fail: "警告——skill agent 文件缺失"

    - check: "lead_permissions_restricted"
      condition: "settings.local.json 中 Lead 只保留 Read/Glob/Grep/Task/SendMessage/TaskList/TaskGet/TaskUpdate"
      on_fail: "阻塞——032号谱系要求"

    - check: "task_stations_derived"
      condition: "至少从中断点派生了一个任务工位（除非中断点为空）"
      on_fail: "警告——可能遗漏工作"

    - check: "crystallization_check"
      condition: "genealogist skill 的结晶检测已执行（扫描近期谱系的背驰+分型信号）"
      on_fail: "警告——可能遗漏结晶时机"

  post_commit:
    ref: ".claude/skills/meta-orchestration/references/post-commit-flow.md"
    description: "commit 后执行的标准流程（session 写入、谱系更新检查）"

# ═══════════════════════════════════════════════════════════════
# 8. 运行时基础设施（从 dispatch-spec 迁移）
# ═══════════════════════════════════════════════════════════════
automation:
  pattern_detection:
    enabled: true
    trigger: "session_end"
    buffer_path: ".chanlun/pattern-buffer.yaml"
    min_sequence_length: 2
    promotion_threshold: 3
  crystallization:
    auto_trigger: true
    require_genealogy_settlement: true
  manifest:
    path: ".chanlun/manifest.yaml"
    auto_register: true

axis_report:
  template:
    sections:
      - "定义基底状态（新增/修改/删除）"
      - "谱系状态（pending 数量、近期结算、结晶信号）"
      - "蜂群工位状态（各工位进度摘要）"
      - "中断点消化进度"
      - "下一步行动建议"
    constraints:
      - "每个 section 不超过 3 行"
      - "只报告变化，不重复已知信息"
  frequency: "每蜂群循环结束"
  producer: "Lead"
  consumers: "所有工位（通过 broadcast 或 session 文件）"

# ═══════════════════════════════════════════════════════════════
# 9. 定义偏序（缠论概念间的逻辑依赖链）
# ═══════════════════════════════════════════════════════════════
definition_partial_order:
  nodes:
    # --- 单标的维度（生成序）---
    - {id: baohan, depends_on: []}
    - {id: fenxing, depends_on: [baohan]}
    - {id: bi, depends_on: [fenxing]}
    - {id: xianduan, depends_on: [bi]}
    - {id: zhongshu, depends_on: [xianduan]}
    - {id: zoushi, depends_on: [zhongshu]}
    - {id: beichi, depends_on: [zoushi]}              # zhongshu 通过 zoushi 传递可达（Hasse 最小化）
    - {id: level_recursion, depends_on: [zoushi, zhongshu]}
    - {id: maimai, depends_on: [beichi]}               # zhongshu/zoushi 通过 beichi 传递可达（Hasse 最小化）
    # --- 跨标的维度（独立分支）---
    - {id: dengjia, depends_on: []}                    # 无前置依赖（筛选条件，非本体关系）
    - {id: bijia, depends_on: [dengjia]}               # 比价分析前提=等价对成立
    - {id: liuzhuan, depends_on: [bijia]}               # dengjia 通过 bijia 传递可达（Hasse 最小化）
