---
id: "016"
title: "规则没有代码强制就不会被执行"
status: "已结算"
type: "meta-rule"
date: "2026-02-17"
depends_on: ["014"]
related: ["005b", "012", "015"]
negated_by: []
negates: []
---

# 016 — 规则没有代码强制就不会被执行

- **状态**: 已结算（语法记录）
- **类型**: meta-rule
- **日期**: 2026-02-17
- **结算依据**: 014实施过程中的实际违反 + hook验证

## 命题

概念层规则（卡/谱系/定义）如果没有对应的 runtime 强制机制（hook/command 内置检查），就不会被 agent 自然执行。知道规则 ≠ 执行规则。

## 发现过程

### 触发事件

014 已结算（SKILL.md → 卡组分解），CC 执行了卡组 merge 到 deploy/。merge 过程中：

1. **未写谱系**——尽管卡上写着"每次概念发现后立刻写入谱系"
2. **未跑质量检查**——尽管 quality-guard 卡定义了"每次产出前检查结果包六要素"
3. **未拉蜂群**——尽管 CLAUDE.md 原则10说"蜂群是默认工作模式"
4. **未用 meta-observer**——尽管 bootstrap 模式本身是一个方法论洞察

CC 在提交 6 张工位卡 + deploy merge 时，这些规则全部被跳过。唯一生效的规则是有代码强制的：stop hook 拦住了未提交文件，precompact hook 保存了 session。

### 关键观察

系统存在三层，中间层是空的：

| 层级 | 内容 | 强制性 |
|------|------|--------|
| 概念层 | 卡/规则/谱系定义 | 完备但不强制 |
| **中间层** | **概念→runtime 的翻译** | **空的** |
| runtime层 | hook/command 内置逻辑 | 强制但只覆盖 git 操作 |

这不是 CC "不认真"——CC 精确复述了所有规则。这是指令型系统的结构局限：指令数量一多、任务一复杂，agent 自然退化为最短路径完成任务，跳过所有不直接产出结果的步骤。

### 验证

安装 pre-commit hook 后测试：修改 `.claude/agents/topology-manager.md` 并尝试提交，hook 成功拦截并要求写谱系。**代码强制的规则被执行了，概念层的规则没有。** 同一个 agent，同一组规则，唯一的区别是有没有 runtime 拦截。

## 推导链

1. 014 结算了"SKILL.md 应拆为卡组"（概念层）
2. deploy/ 中的 633 行 SKILL.md 仍然存在（filesystem 现实）
3. 编排者手动指示 merge（bootstrap 第一步）
4. CC 执行 merge 但跳过了卡上定义的所有流程（谱系/质量检查/蜂群）
5. 编排者发现并指出
6. CC 自我诊断：唯一被执行的规则是有代码强制的
7. ∴ 关键规则必须从概念层下沉到 runtime 层
8. pre-commit hook = runtime 强制层的第一颗种子
9. hook 验证通过 → 正反馈循环可以启动

## 被否定的方案

- **"写更多规则"**：规则本身就是概念层产物，不解决概念→runtime 的翻译缺口。谁来强制执行"强制执行规则的规则"？无限回退。
- **"CC 应该更认真"**：归因于 agent 态度而非系统结构。止步于现象，不触及原因。

## 新产出

- `.git/hooks/pre-commit`：概念层文件变更时强制检查谱系条目
- `deploy/hooks/pre-commit-genealogy-check.sh`：hook 的可部署版本
- `deploy/install.sh`：增加 hook 安装步骤

## 影响

- **runtime 强制层从此存在**：不再是纯概念系统。第一个 hook 证明了"代码强制 > 文字要求"
- **后续 hook 方向**：产出前质量检查（/commit 内置）、ceremony 后蜂群评估（自动输出）
- **bootstrap 循环**：hook 存在 → CC 被迫写谱系 → 写谱系过程产生发现 → 发现催生新 hook → 更多规则被强制执行

## 谱系链接

- **前置**: 014（SKILL.md 卡组分解）— 本条是 014 实施过程中的发现
- **前置**: 015（方法不外在于内容）— 本条是 015 的实践验证：方法说"写谱系"，但方法自身的实施没写谱系
- **前置**: 012（谱系是发现引擎）— hook 强制写谱系 = 强制触发发现引擎
- **关联**: 005b（对象否定对象）— 在 runtime 层的同构：规则（概念对象）被 hook（runtime 对象）否定其"可选性"

## 来源

- [新缠论] — 编排者在实践中的诊断："唯一被执行的规则是有代码强制的"
- 直接触发：编排者观察到 CC 实施 014 时跳过了谱系/质量检查/蜂群
