---
id: "046"
title: "一域一角（One Domain One Role）"
status: "已结算"
type: "语法记录"
date: "2026-02-20"
depends_on: ["005b", "013", "032", "037"]
related: ["038", "039", "045"]
negated_by: []
negates: []
---

# 046 — 一域一角（One Domain One Role）

**类型**: 语法记录
**状态**: 已结算
**日期**: 2026-02-20
**negation_source**: heterogeneous（Gemini decide）
**negation_form**: expansion（037号"递归蜂群分形"深化：从"可 spawn"到"应 spawn unless 强耦合"）
**前置**: 037-recursive-swarm-fractal, 005b-object-negates-object-grammar, 013-swarm-structural-stations, 032-divine-madness-lead-self-restriction
**关联**: 038-single-agent-bypass-bias, 039-single-agent-bypass-pattern, 045-no-structure-no-task

## 现象

037号结算了"递归蜂群分形"——任何 teammate 面对可分解的子任务时可以 spawn 子 teammates。038号和039号结算了"单 agent 绕过偏差"——Lead 倾向于跳过蜂群以单 agent 模式执行。但两者之间存在一个未显式化的中间地带：Lead 确实拉了蜂群，但将多个独立任务打包给单个工位。

在本 session（v5-full-push）中：
- hook-validator 被打包 #1（hook 验证）+ #2（meta-observer.md 修复）— 两个不同域的任务
- code-refactor 被打包 #5（大函数重构）+ #8（CI 配置）— 重构与 CI 是不同域

打包的后果：
1. 任务 B 的进度被任务 A 的执行状态阻塞（即使 B 本身已可执行）
2. 工位的上下文窗口被多任务污染，注意力稀释
3. 单工位失败时多个不相关任务同时受影响
4. 谱系追踪粒度降低——genealogist 无法区分哪个产出来自哪个任务

## 推导链

1. 005b（对象否定对象）：任务 B 的存在性不能被任务 A 的运行状态否定。当 A 和 B 打包在同一工位中，A 的失败/阻塞事实上否定了 B 的执行机会——这不是对象事件（B 本身没有产生否定信号），而是外部调度决策造成的否定，语法不合法
2. CLAUDE.md 规则 #1（概念优先于代码）：上下文隔离是概念层需求（每个任务有独立的认知域），API 成本是代码层优化。概念层需求优先于代码层优化
3. 级别 = 递归层级（006号）：Lead 只做路由（032号），不做调度优化。将多任务打包给单工位是调度优化行为，属于 Lead 越权
4. 037号（递归蜂群分形）深化：037 说"可以 spawn 子 teammates"，但未说明何时"应该" spawn。本条将其深化为"应 spawn unless 强耦合"——默认是拆分，合并是例外

## 已结算原则

**一域一角：蜂群递归中，每个独立任务/子任务/职责应 1:1 映射到单一 teammate。**

### 打包的三个必要条件（全部满足才允许合并）

| 条件 | 含义 | 检验方式 |
|------|------|---------|
| 强上下文耦合 | 任务 A 的产出是任务 B 的直接输入，且中间状态不可序列化 | A 完成后 B 是否可以由另一个工位独立执行？如果可以，则不耦合 |
| 工具集一致性 | 两个任务需要完全相同的工具集和权限 | tools_required 列表是否相同？ |
| 原子性事务 | 两个任务必须作为一个原子操作成功或失败，不允许部分完成 | A 成功但 B 失败时，系统状态是否一致？如果一致，则非原子 |

### 本 session 违规分析

| 打包 | 强上下文耦合 | 工具集一致 | 原子性事务 | 判定 |
|------|------------|-----------|-----------|------|
| hook-validator: #1 + #2 | 否（hook 验证与 meta-observer.md 修复无直接数据依赖） | 部分（都用 Read/Edit/Bash，但 #2 还需要 Grep） | 否（#1 成功 #2 失败不影响系统一致性） | 违规 |
| code-refactor: #5 + #8 | 否（大函数重构与 CI 配置无直接数据依赖） | 否（#5 用 Read/Edit，#8 用 Bash/Write 操作 CI 配置） | 否（#5 成功 #8 失败不影响系统一致性） | 违规 |

### 与 038/039 的关系

038/039 诊断的是"不拉蜂群"（单 agent 绕过）。046 诊断的是"拉了蜂群但打包不当"。三者形成一个偏差谱系：

```
完全绕过（039）→ 形式蜂群但打包（046）→ 正确的 1:1 映射
```

046 是 039 的"改良版绕过"——Lead 遵守了"必须拉蜂群"（038 G8 规则），但通过打包多任务给单工位，事实上减少了 spawn 数量，部分回退到单 agent 模式。

## 被否定的方案

- **"按 API 成本优化打包"**：将多个小任务打包给单工位以减少 spawn 开销。被 CLAUDE.md 规则 #1 否定——概念优先于代码，上下文隔离是概念层需求，API 成本是代码层优化
- **"按工具集相似性打包"**：工具集相似的任务合并。被 005b 否定——工具集相似不等于认知域相同，任务 B 不应被任务 A 的运行状态否定
- **"Lead 自行判断是否打包"**：Lead 根据经验判断哪些任务可以合并。被 032号否定——Lead 只做路由，不做调度优化。打包决策是调度优化，属于 Lead 越权

## 边界条件

- 如果三个必要条件全部满足（强耦合 + 工具一致 + 原子事务）→ 打包合法，不违反本原则
- 如果 teammate 总数接近平台硬限制 → 可能需要打包，但应优先通过递归蜂群（037号）的层级化 spawn 解决，而非扁平打包
- 如果任务粒度过细（如"修改一行代码"级别）→ 1:1 映射可能导致 spawn 开销超过收益。但 043号的效用背驰机制应在此处生效——spawn 的效率提升不再覆盖复杂度增加时停止拆分
- 本原则适用于任务工位。结构工位的职责是固定的（013号），不存在打包问题

## 影响声明

- 037号"递归蜂群分形"从"可 spawn"深化为"应 spawn unless 强耦合"——默认拆分，合并是需要证明的例外
- dispatch-spec.yaml 应新增打包条件检查（三个必要条件）作为 Lead 路由时的验证规则
- 038号 G8（无简单任务豁免）获得补充：不仅不能跳过蜂群，也不能通过打包变相减少工位数量
- 为 meta-observer 提供新的检查项：蜂群中是否存在多任务打包的工位
