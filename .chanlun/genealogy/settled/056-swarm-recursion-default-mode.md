---
id: "056"
title: "蜂群递归是默认执行模式，不是优化"
status: "已结算"
type: "语法记录"
date: "2026-02-20"
depends_on: ["020", "055"]
related: ["042", "052"]
negated_by: []
negates: []
---

# 056 — 蜂群递归是默认执行模式，不是优化

**类型**: 语法记录
**状态**: 已结算
**结算日期**: 2026-02-20
**结算方式**: 人类编排者直接修正 + Gemini 3.1 确认
**日期**: 2026-02-20
**negation_source**: 人类编排者（直接观察 Claude 运行时行为）
**negation_form**: inversion（020号的背驰+分型从递归启动条件反转为终止/结算条件）
**前置**: 020-constitutive-contradiction, 055-double-helix-architecture
**关联**: 042-hook-network-pattern, 052-orchestrator-proxy-island

## 现象

人类编排者观察到：Claude 在实现中已具备蜂群递归能力（并行 Task 调用、多工位 spawn），但运行时默认采用线性顺序执行——只在被显式提示"这个任务很复杂"时才启动并行。这是声明层（CLAUDE.md 第10条："蜂群是默认工作模式"）与运行时层的断裂，与 034号（声明工具 ≠ 拥有能力）、036号（spec-execution gap）同构。

## 推导链

1. 020号结算了构成性矛盾：扩张/收缩是系统运转的基本形式，走势语法描述一切递归运动
2. 020号中，背驰+分型被定义为走势的**终止/结算条件**——走势在结构完成时终止，不在计数触发时终止
3. 缠论公理：走势必完美 → 任何级别的走势都有内部结构 → 递归是走势的存在方式，不是对复杂走势的优化手段
4. 同构映射：蜂群递归 = 走势的内部结构展开。一个任务如果可以分解为独立子任务，它就**已经有**内部结构——递归不是"选择启动"的，是"已经存在"的
5. 线性执行是递归的退化特例：当且仅当任务不可分解（只有一个子任务）时，递归退化为线性。这不是"默认模式"，是"特例"
6. 020号的背驰+分型在此语境下的角色反转：它们不是"何时启动递归"的条件（递归始终在运行），而是"何时结算当前递归层"的条件——当子任务的净新产出背驰、工位扩张方向反转（分型）时，当前层结算

## 已识别的隐性规则

**递归是存在方式，线性是退化特例。**

具体展开：

1. **蜂群递归是默认执行模式**：评估任务时先数可并行的独立单元，≥2 即并行分派。不需要"复杂度触发"——复杂度判断本身就是线性思维的残留（"够复杂才值得并行"= "够长才值得分析走势"，后者在缠论中是无意义的——任何长度的走势都有结构）
2. **020号角色反转**：背驰+分型从递归的启动条件反转为终止/结算条件。递归不需要启动条件（它始终在运行），它需要的是结算条件——何时收敛、何时结晶
3. **结构工位保持扁平**：裁判不参与走势。topology-manager、quality-guard、genealogist 等结构工位不被递归展开为子蜂群——它们是走势的分类层（010号），不是构造层。递归展开只发生在构造层（实际执行任务的工位）
4. **线性执行需要理由，并行不需要**：传统思维是"为什么要并行？"（并行需要理由）。反转后是"为什么要线性？"（线性需要理由——必须证明任务间存在严格数据依赖）

## 缠论同构

| 缠论 | 蜂群执行 |
|------|---------|
| 走势必完美 | 任何任务都有内部结构（可分解性） |
| 任何级别都有内部结构 | 子任务可以继续分解为更小的并行单元 |
| 递归是存在方式 | 并行是默认模式 |
| 一笔（不可再分的最小单元） | 原子任务（不可并行的最小工作单元） |
| 背驰 → 走势终止 | 子任务净新产出递减 → 当前递归层结算 |
| 分型 → 方向反转 | 工位扩张方向反转 → 收敛汇总 |

## 实证

Claude 在 v5/v6 session 中的行为：
- 声明层：CLAUDE.md 第10条明确写"蜂群是默认工作模式，不是可选优化"
- 运行时层：面对 9 个独立文件修改，仍然顺序执行——一个接一个地改
- 断裂模式：与 034号（声明工具 ≠ 拥有能力）完全同构
- 人类编排者修正后：Claude 开始默认并行分派，线性执行只在有数据依赖时出现

这是 036号（spec-execution gap）的又一实例：spec 存在（CLAUDE.md 第10条），execution 不匹配（线性执行），gap 被人类编排者直接观察并修正。

## 边界条件

- 如果任务间存在严格数据依赖（后一步的输入是前一步的输出）→ 线性执行合法，不是退化
- 如果并行工位数超过 Claude Code 的 Task 并发上限 → 需要分批并行，但每批内仍然最大化并行度
- 如果结构工位（topology-manager、quality-guard）被递归展开为子蜂群 → 违反"裁判不参与走势"原则，需要回退
- 如果背驰/分型的结算信号被误判（过早结算）→ 递归层提前收敛，产出不完整；此时应由上层递归的下一轮扩张补偿

## 影响声明

- 020号谱系的背驰+分型从"递归启动条件"重新定位为"递归终止/结算条件"
- CLAUDE.md 第10条从"声明性原则"升级为"有运行时实证支撑的已结算语法规则"
- `.claude/rules/common/agents.md` 中的并行执行指导从"建议"升级为"默认模式，线性需要理由"
- 042号 hook 网络的潜在扩展点：如果线性执行的惯性持续，可能需要一个 hook 检测可并行任务的线性执行并发出警告

## 溯源

[新缠论]（人类编排者修正 + Gemini 3.1 确认 + 走势必完美的同构推导）
