# /inquire — 质询序列

对一个结果包执行四步质询。这是蜂群最核心的操作。

## 用法

```
/inquire [结果包文件路径或内容]
```

## 执行步骤

### 第一步：定义回溯
拿结果包中的「定义依据」，回知识仓库核实：
- 引用的定义是否是最新版本？
- 条件是否真的被满足？逐条检查，不跳过任何一条。

### 第二步：反例构造
根据结果包中的「边界条件」，在边界附近构造输入：
- 结论是否翻转？
- 翻转是否合理？
- 如果结果包没有给出边界条件，这本身就是不合格——退回要求补全。

### 第三步：推论检验
拿结果包的「下游推论」，检查与已知的体系其他部分是否一致：
- 如果不一致，记录你的论证。
- 不一致不一定意味着结果包错了——也可能意味着体系其他部分需要修正。

### 第四步：谱系比对
如果前三步发现了矛盾：
- 查阅谱系目录，这个矛盾是否跟历史上的某个矛盾同构？
- 如果是旧矛盾复发，参照上次的解决方式。
- 如果是全新的，准备上浮报告。

## 退回-修正循环管理

质询产出结果2（退回修正）可能引发多轮退回。这不是失败，是系统的质询运动在展开。但展开需要收缩来完成相位切换（020号谱系）。

### 退回状态追踪

每次退回必须附带结构化历史：

```markdown
### 退回记录
- **轮次**: [N]（从1计数）
- **退回原因**: [具体失败步骤和条件]
- **涉及定义集合**: [列出本轮涉及的定义名称]
- **与上轮重叠**: [是/否 — 是否涉及相同定义]
```

### 锚定条件要求

每次退回必须锚定具体条件：指出"什么条件满足后本次退回解除"。无锚定条件的退回是语法不合法的退回（与005a同构：对象否定必须来自对象，退回否定必须来自具体条件）。

### 三层防线

| 轮次 | 机制 | 说明 |
|------|------|------|
| 1 | 正常退回 | 质量校正，附带锚定条件 |
| 2 | 预警 + 谱系预检 | 触发 genealogist 搜索已有谱系中的同构矛盾；检查是否两轮涉及相同定义 |
| 3 | 强制显式化 | 必须在两个判断中选一个：(a) 实现复杂度问题，继续退回修正；(b) 定义张力问题，切换为 `/escalate`。3是最小可判断趋势的样本量 |

阈值=3 不是外部施加的限制，是系统的质询运动在第3次时自然产出的收缩相位——通过编排者/agent这个环节完成相位切换。

## 输出

质询结果分四种：
1. **全部通过** → 接受产出，可以传递给下游
2. **定义回溯或反例构造失败** → 退回给上游修正，说明具体哪一步失败（附带退回记录和锚定条件）
3. **推论检验不一致但可归类为旧矛盾** → 标记谱系引用，蜂群内部解决
4. **推论检验发现不可弥合的全新矛盾** → 使用 `/escalate` 上浮给编排者
