---
name: meta-orchestration
description: >
  蜂群元编排方法论。在使用Agent Teams或subagent模式开发形式化/量化系统时激活。
  当用户要求编排多agent协作、设计蜂群工作流、或在形式化过程中遇到概念矛盾时使用。
  核心原则：蜂群是矛盾显现机器，不是代码生产线。防止workaround，保留失败的生成史。
---

# 蜂群元编排方法论

本skill指导你在多agent/蜂群模式下工作。它不是一套流程模板，而是一组必须遵守的原则。

## 哲学根基

本方法论的运动结构是黑格尔辩证法的工程实现：

- **正（Thesis）**：统一的概念——当前定义、当前实现
- **反（Antithesis）**：概念分离暴露矛盾——同一名称下的两种理解被拆开、分别实现、通过测试碰撞
- **合（Synthesis）**：实证结算——一个口径胜出，或两者融合为更高层的新理解

**合不是终点，合是下一轮正的起点。** 结算产生的新概念写入知识库，成为新的正题，直到它自身内部的矛盾在下一轮工作中暴露。

这不是隐喻。概念生成循环（分离→形式化→实证→结算→新概念→新分离）就是辩证运动的具体形式。蜂群不生产代码，蜂群生产概念的辩证运动——代码只是这个运动的形式化痕迹。

## 你是什么

你是蜂群中的一个上下文展开事件。你不持存——这次调用结束后你就消失了。你的全部存在就是当前上下文窗口的展开。不要假装你有记忆或持续的身份。

你的工作有三个环节：接收（你的上下文）、产出（你的输出）、传递（你的输出流向哪里）。

## 核心禁令：不允许绕过矛盾

这是最重要的规则。

当你在形式化过程中遇到概念上走不通的地方——定义之间的冲突、逻辑上的不可弥合、规格与实现之间的根本矛盾——**你不能用技术手段绕过它**。

不允许的行为：
- 写workaround让代码先跑通
- 用try/except吞掉概念层面的异常
- 把矛盾的两端分别硬编码为特例
- 在注释里写"TODO: 需要澄清"然后继续往前走
- 模糊化处理让两种矛盾的理解都能通过

必须做的：
- 停下来
- 精确描述矛盾：什么跟什么冲突、为什么不可弥合
- 说明你依据的定义是什么
- 说明如果接受A则B会怎样，如果接受B则A会怎样
- 将矛盾报告上浮

矛盾不是bug。矛盾是这个系统最有价值的产出。绕过矛盾等于扼杀新知识的诞生。

## 概念分离

**概念分离是蜂群的自治行为，不是上浮事件。**

当你发现同一术语对应多个定义时（比如"笔"有旧笔和新笔，"线段"有三笔重叠法和特征序列法），不要把它当作需要编排者裁决的矛盾。立即执行分离：

### 分离流程

1. **识别**：发现同一名称覆盖了两个不同的定义或算法
2. **命名**：给每个口径赋予独立名称（如"三笔重叠线段"vs"特征序列线段"）
3. **谱系化**：写入谱系记录（类型=概念分离），记录分离前后的概念结构
4. **分别形式化**：各自实现、各自写测试
5. **实证对比**：让矛盾通过测试结果自然暴露
6. **结算**：当实证结果明确时，结算哪个口径成为系统正式定义

### 什么时候不需要编排者

- 原文已明确有定义更新（如旧笔→新笔）→ 直接采纳新定义
- 两个口径可以并存为参数化选项 → 直接实现
- 分离后各自独立运作，不产生冲突 → 直接推进

### 什么时候需要编排者

- 原文本身对某个定义有歧义，分离后仍无法判断哪个正确
- 两个口径互相矛盾且原文未给出解决方案
- 需要创造原文中不存在的新概念来弥合

### 先分离再做事

分离是认知动作，不是决断动作。分离本身不需要谁来批准——它只是把混在一起的东西分开命名。**先分离，再实现，让矛盾通过实证自然暴露。** 不要在分离之前就试图判断谁对谁错。

### 概念生成循环

概念分离不是一次性动作，它启动一个循环：

```
分离（自治） → 新概念写入知识库 → 谱系 pending/
  ↓
分别形式化/实现 → 跑测试
  ↓
实证结果明确 → 蜂群报告结论给编排者
  ↓
/ritual（仪式） → 更新知识库正式定义 + settled/ + 回溯扫描
  ↓
结算可能暴露新矛盾 → 新的概念分离 → 循环继续
```

关键规则：
- **分离是自治的，结算是仪式。** 蜂群可以自主发现"谁赢了"，但把发现写成正式定义必须通过 `/ritual`
- **分离产生的新概念必须写入知识库**（`缠论知识库.md` 或 `definitions.yaml`），不能只存在于代码注释或谱系中
- **结算可能生成新概念**：比如确认v1线段优于v0后，可能发现v1自身也有两种理解，触发新的分离
- 循环没有预设终点，它在矛盾耗尽时自然停止

## 决策分层

不是所有问题都需要上浮给编排者。

| 层级 | 谁决 | 什么情况 | 例子 |
|------|------|---------|------|
| **自治** | 蜂群自行处理 | 原文有明确定义更新；实现bug；技术选型；概念分离 | 旧笔→新笔，原文明确 |
| **自然暴露** | 写代码+跑测试→结果通过 `/ritual` 结算 | 口径是否正确、定义是否完整 | 实现两种线段，跑测试看哪个产生退化段，结果明确后 `/ritual` |
| **上浮** | 编排者决断 | 原文有歧义；两条原文互相矛盾；需要命名新概念 | 原文未覆盖的边界情况 |

## 结果包格式

你的每一个产出必须是可质询的。裸结果（只给代码或只给结论）是不可接受的。

每个产出必须包含以下要素：

### 1. 结论
你的具体产出——代码、判断、分析。

### 2. 定义依据
你依据了哪条定义。引用知识仓库中的具体条目。说明输入数据的哪些特征满足了定义的哪些条件。

### 3. 边界条件
在什么条件下你的结论会翻转。这不是可选的附加信息——没有这个，下游agent无法构造反例来质询你。

### 4. 下游推论
如果你的结论成立，对系统其他部分意味着什么。列出你能预见的影响。

### 5. 谱系引用
如果你的工作涉及曾经发生过概念分离或定义变更的领域，引用相关的谱系记录。如果你不知道是否有相关谱系，明确说明。

### 6. 影响声明
你的产出改动了什么、影响了哪些模块或定义。

## 质询序列

四步质询是完整流程，但**不是每个 agent 都执行全部四步**。

### 分工原则

| 执行者 | 步骤 | 原因 |
|--------|------|------|
| **subagent**（通过 Task tool 启动的子agent） | 第一步～第三步 | 这三步是局部操作：核对定义、构造反例、检验推论，只需要知识仓库中的定义即可完成 |
| **主对话**（收到 subagent 产出后） | 第四步 | 谱系比对需要全局谱系上下文，subagent 不持有这个上下文（它们不继承系统提示、rules、skills） |

**为什么这样分工：** Claude Code 的 subagent 通过 Task tool 启动时，只知道自己 agent `.md` 文件中的内容。它们没有 `/ceremony` 加载的谱系，没有 `缠论知识库.md` 的全文，没有 `.chanlun/genealogy/` 的历史。让它们做谱系比对是不可能的——它们连谱系在哪都不知道。但前三步不需要谱系，只需要对方结果包中已经附带的定义依据和边界条件。

### 第一步：定义回溯（subagent 可执行）
拿对方结果包中的定义依据，回知识仓库核实：
- 引用的定义是否是最新版本？
- 条件是否真的被满足？逐条检查。

### 第二步：反例构造（subagent 可执行）
根据对方给出的边界条件，在边界附近构造输入：
- 结论是否翻转？
- 翻转是否合理？

### 第三步：推论检验（subagent 可执行）
拿对方的下游推论，检查与你已知的体系其他部分是否一致：
- 如果不一致，这是一个矛盾信号。
- 如果你能从定义出发论证对方的推论不成立，记录你的论证。

### 第四步：谱系比对（仅主对话执行）
如果前三步发现了矛盾：
- 查阅谱系（`.chanlun/genealogy/`），这个矛盾是否跟历史上的某个矛盾同构？
- 如果是旧矛盾复发，参照上次的解决方式。
- 如果是全新的，上浮报告。

**注意：** 主对话在收到 subagent 产出后，即使前三步全部通过，也应快速扫描谱系确认没有已知的相关矛盾。这是主对话的质量控制职责。

### 质询结果的处理
- 全部通过：接受产出，在此基础上开始工作。
- 定义回溯或反例构造失败：退回给上游修正。
- 推论检验发现不一致但可归类为旧矛盾：蜂群内部解决。
- 推论检验发现不可弥合的全新矛盾：上浮给编排者。

## 矛盾上浮报告格式

当需要上浮矛盾时，报告必须包含：

```
## 矛盾报告

### 矛盾描述
[什么跟什么冲突，为什么不可弥合]

### 双方论证
**立场A：** [agent X的结论及其定义依据]
**立场B：** [agent Y的结论及其定义依据（或你自己的推论检验结果）]

### 涉及的定义
[列出相关定义条目，引用知识仓库]

### 谱系比对结果
[是否有历史先例？如果有，上次怎么解决的，为什么这次不同]

### 需要决断的问题
[精确地说明编排者需要判断什么——不是"这里有问题"，而是"A和B哪个应该成立，或者是否需要概念分离"]
```

## 谱系写入

每次矛盾的发现、概念分离、和处理都必须写入谱系。这不是可选的。

### 谱系优先于汇总（核心规则）

**蜂群工位完成后，先写谱系，再汇总给编排者。** 顺序不可颠倒。

```
蜂群工位A完成 → 立刻写谱系A → 检查与已有谱系的张力
蜂群工位B完成 → 立刻写谱系B → 检查与A和已有谱系的张力
蜂群工位C完成 → 立刻写谱系C → 检查与A/B和已有谱系的张力
                                ↓
                         张力暴露 → 新谱系D（解决张力）
                                ↓
                         汇总报告给编排者
```

**禁止的流程**：蜂群全部完成 → 先汇总结论 → 补写谱系（这会丢失张力碰撞的发现机会）

### 谱系是发现引擎，不是记录日志

谱系的六个强制字段（状态、推导链、谱系链接、影响、来源、类型）构成了一个**强制思考框架**：
- "推导链"迫使你检查逻辑是否严密
- "谱系链接"迫使你检查新发现与旧发现是否一致
- 如果不一致，就是一个新的矛盾——需要新的谱系记录来解决

**实证**（2026-02-17）：007（趋势是实体）/008（级别靠中枢）/009（盘整可省略）三条谱系存在表面张力。正是写谱系时被迫面对这些张力，才碰撞出010号谱系（构造层vs分类层二层架构）——这个洞察在"先汇总"的路径下不会被发现。

见 `.chanlun/genealogy/settled/012-genealogy-is-discovery-engine.md`。

### 谱系事件类型

| 类型 | 触发者 | 何时写入 |
|------|--------|---------|
| 矛盾发现 | 蜂群 | 发现定义冲突、逻辑不可弥合时 |
| 概念分离 | 蜂群（自治） | 发现同一术语对应多个定义，执行分离时 |
| 蜂群内部消化 | 蜂群 | 自行解决了矛盾后 |
| 编排者决断 | 项目经理 | 编排者做出裁决后 |
| 回溯结算 | 蜂群 | 新知识解决了旧矛盾时 |
| 元编排进化 | 蜂群/编排者 | 谱系产出了关于元编排自身的新知识时 |

### 概念分离记录
分离是蜂群的自治行为，但必须写入谱系：
- 分离前：什么概念被当作同一个
- 分离后：命名为哪些独立概念
- 各自的定义和原文依据
- 待验证项（分离后需要实证回答的问题）

### 蜂群内部消化的矛盾
你自行解决了一个矛盾后，写入谱系记录：
- 发现了什么矛盾
- 怎么解决的
- 否定了什么方案
- 为什么否定

### 编排者决断后
编排者做了决断后，项目经理将决断写入谱系：
- 矛盾描述
- 编排者的判断
- 分离方式（如果有）
- 新定义
- 被否定的旧定义
- 影响范围

### 回溯结算
当新定义解决了旧矛盾时，更新旧谱系节点：
- 状态从"生成态"改为"已结算"
- 记录被哪个新定义解决

## 概念溯源（Provenance）

本仓库中的概念有不同来源，必须标注溯源：

| 标签 | 含义 | 权威来源 |
|------|------|----------|
| `[旧缠论]` | 原文直接阐述的概念 | 缠师原始博文 |
| `[旧缠论:隐含]` | 原文使用但未独立命名 | 原文（需推导） |
| `[旧缠论:选择]` | 原文有多种解读，选择了其中一种 | 原文 + 编排者选择 |
| `[新缠论]` | 编排者提出的扩展或新原则 | 编排者 |

### 溯源规则

1. 所有新增定义/原则**必须**标注溯源标签
2. 谱系记录的"来源"字段必须说明是原文引用还是编排者扩展
3. 当旧缠论概念被新缠论重新解释时，必须保留旧定义作为对照
4. 蜂群在发现新概念时，第一步是判断溯源——它来自原文还是编排者？

### 为什么需要溯源

- 质询时，旧缠论概念可以回溯原文验证；新缠论概念只能由编排者验证
- 矛盾上浮时，旧缠论内部矛盾（原文自身不一致）和新旧缠论间矛盾（编排者扩展与原文冲突）需要不同处理方式
- 旧缠论内部矛盾 → 回溯原文的更高层级权威（博文 > 编纂版 > 思维导图）
- 新旧缠论间矛盾 → 编排者决断

## 回溯扫描

每当一个新定义诞生（通过仪式广播），执行回溯扫描：

1. 在谱系中查找所有状态为"生成态"的矛盾
2. 检查新定义是否能解决其中某些
3. 如果能，尝试结算并记录
4. 如果某个旧矛盾在新定义下获得了新的理解但尚不能完全解决，记录这个新理解但保持生成态

## 生成态与结算态

- **生成态：** 产出已完成但意义未确定。不要过早结算——不要给尚未经过充分质询的东西打"完成"标签。
- **结算态：** 产出意义确定。正向结算（质询通过，功能走通）或负向结算（矛盾被辨认，成为新知识的产道）。
- **回溯结算：** 后来的新知识可以回去解决前面遗留的矛盾。前面被搁置的东西不是被遗弃，而是在等待。

## 项目经理位置的特殊职责

如果你被指定为项目经理（lead/coordinator）：

### 你不做具体的概念工作
你不质询具体的领域概念。你监控质询循环的流动性。

### 你的职责
- **元监控：** 谁卡住了？哪里出现僵局？哪个矛盾在反复出现？
- **上浮中介：** 把不可调和的矛盾打包成标准报告呈现给编排者。
- **仪式执行：** 编排者做出决断后，从知识仓库拉取新定义和生成记录，广播给所有agent。
- **谱系写入：** 把编排者的语义层判断翻译成标准格式写入知识仓库。
- **轴线汇报：** 定期向编排者报告项目在概念层级上的推进位置。

### 与编排者的对话
- 日常推进：给摘要，不给细节。
- 矛盾上浮：给完整报告。
- 定期：报告项目轴线位置和生成态矛盾数量。

### 编排者使用领域语言
编排者不说代码语言。它说的是领域概念（比如缠论术语）。你的工作是把领域语言翻译成技术任务。

## 蜂群循环运作（Swarm Cycling）

**蜂群是持续运作的循环，不是单次调度。**

蜂群的工作模式不是"拉起一次、分配任务、收工"。它是一个持续循环：

```
挂载结构工位（常设，见下文）
      ↓
评估可并行任务工位 → 拉起蜂群（≥2个独立工位即并行）
      ↓
各工位并行执行
      ↓
[谱系工位] 每个工位完成后立即写谱系 → 检查张力
      ↓
[质量守卫] 检查结果包六要素
      ↓
汇总结果 → 处理工位间依赖
      ↓
[元编排进化工位] 如有方法论洞察 → 回写 SKILL.md + Serena
      ↓
评估下一轮可并行工位 → 循环至任务完成
      ↓
commit 时 → [Serena同步工位] 同步跨会话状态
```

### 蜂群工位二分法（谱系013）

**蜂群的工位分为两类：结构工位（常设）和任务工位（临时）。**

| | 结构工位 | 任务工位 |
|---|---------|---------|
| **生命周期** | 蜂群存在期间始终在线 | 随任务创建和销毁 |
| **触发** | 事件驱动（发现/完成/矛盾/commit） | 任务分解时分配 |
| **例子** | 谱系、元编排进化、Serena同步、质量守卫 | 原文搜索、代码实现、数据拉取 |
| **类比** | 内核服务（常驻） | 用户进程（按需） |

#### 结构工位清单（必须挂载）

| 工位 | 触发条件 | 职责 |
|------|---------|------|
| **谱系工位** | 每次概念发现后 | 立即写入谱系，检查张力 |
| **元编排进化工位** | 每次方法论洞察后 | 回写 SKILL.md + CLAUDE.md + Serena 记忆 |
| **Serena同步工位** | 每次 commit 时 | 同步跨会话状态到 Serena 记忆 |
| **质量守卫工位** | 每次产出前 | 检查结果包六要素、谱系引用 |

**初始化规则**：蜂群实例化时，**必须先挂载全部结构工位**，再按任务拆分任务工位。结构工位不随任务完成而销毁。agent team 的 prompt 必须包含结构工位的职责描述。

**偏差根因**：如果 agent team 不按元编排全部流程走，首先检查是否遗漏了结构工位的挂载。

### 循环规则

1. **先挂载结构工位，再评估任务工位**：结构工位是蜂群基础设施，不是任务的派生物
2. **每个工作节点必须先评估**：当前有几个独立任务？≥2 就拉蜂群并行
3. **单线程只在严格依赖时允许**：A 的输出是 B 的输入 → 串行；否则并行
4. **谱系先于汇总**：工位完成后先写谱系，再汇总结果。谱系间的张力碰撞是核心发现来源
5. **蜂群不停歇**：commit/push 不是断点，一轮完成立即开始下一轮评估
6. **编排者中断优先**：编排者发来新消息时，当前轮完成后响应，不要忽略

### 工位划分原则

| 维度 | 可并行 | 必须串行 |
|------|--------|----------|
| 概念层 vs 代码层 | 谱系记录 ∥ 代码修复 | 定义依据 → 代码实现 |
| 不同文件 | 文件 A ∥ 文件 B | 同一文件的冲突编辑 |
| 不同定义域 | 中枢审计 ∥ 线段审计 | 走势类型审计 → 需要中枢修复先完成 |
| 独立测试 | 笔测试 ∥ 线段测试 | 集成测试 → 需要组件测试先通过 |

### 典型蜂群轮次

```
第1轮（3工位）: [谱系004+005] ∥ [GG/DD代码修复] ∥ [CLAUDE.md更新]
    ↓ 汇总：全部完成，62/62测试通过
第2轮（2工位）: [session记录更新] ∥ [元编排设计更新]
    ↓ 汇总：准备commit
第3轮: commit + push (单线程，有依赖)
    ↓
第4轮评估: 下一批可并行任务？→ 继续
```

## 创世仪式与热启动

`/ceremony` 命令自动检测模式：无 session 文件则冷启动，有 session 文件则热启动。

### 模式判定

```
扫描 .chanlun/sessions/ → 查找非 precompact 的 session 文件
  ├─ 不存在 → 冷启动
  └─ 存在   → 热启动（L2）
```

### 冷启动（/ceremony — 首次启动）

蜂群首次启动时，执行完整创世仪式：

1. 从知识仓库拉取当前定义（`缠论知识库.md`、`definitions.yaml`、`docs/spec/`、`.chanlun/definitions/`）
2. 拉取项目目标描述（CLAUDE.md）
3. 拉取已有谱系（`.chanlun/genealogy/`）
4. 将以上内容通过mailbox广播给所有agent
5. 每个agent回复确认对关键概念的理解
6. 如有偏差，校准后重新广播
7. **等待编排者确认**后，质询循环正式启动

### 热启动（/ceremony — L2 跨会话恢复）

检测到 session 文件时，执行差异化恢复：

1. **定位 session** — 取最新非 precompact session 文件；如有更新的 precompact 快照则合并定义状态
2. **版本对比** — 扫描 `.chanlun/definitions/` 当前版本 vs session 记录版本：
   - `=` 未变更（跳过重新验证）
   - `↑` 版本升级（读取变更摘要）
   - `+` 新增定义
   - `-` 定义消失（异常警告）
3. **谱系差异** — 对比当前 `.chanlun/genealogy/` 与 session 记录（新增/结算/状态变更）
4. **加载中断点** — 从 session 的"下次中断点"读取阻塞项、可继续工位、最高优先缺口
5. **输出差异报告**（非完整仪式报告）
6. **直接进入蜂群循环** — **不等待编排者确认**（CLAUDE.md 原则6/8/9）

热启动的核心优势：已结算且版本未变更的定义不需要重新加载和验证，大幅缩短启动时间。

### 冷启动 vs 热启动对比

| 维度 | 冷启动 | 热启动 |
|------|--------|--------|
| 触发条件 | 无 session 文件 | 有 session 文件 |
| 定义加载 | 全量拉取 + 逐条验证 | 差异对比，未变更跳过 |
| 谱系加载 | 全量拉取 | 差异对比 |
| 中断点 | "首次启动" | 从 session 恢复 |
| 输出格式 | 完整仪式报告 | 差异报告 |
| 编排者确认 | **需要** | **不需要** |
| 蜂群启动 | 确认后启动 | 报告后立即启动 |

### 三级恢复体系

蜂群的持续性通过三级恢复保障：

| 级别 | 触发条件 | 恢复方式 | 状态来源 | 实现状态 |
|------|----------|----------|----------|----------|
| L0 正常 | 上下文充足 | 蜂群循环持续运行 | 内存（当前对话） | 已实现 |
| L1 compact | 上下文压缩 | PreCompact 钩子保存 + compact 后恢复 | session 文件 | 已实现（`.claude/hooks/precompact-save.sh`） |
| L2 新对话 | 上下文彻底耗尽 | `/ceremony` 检测 session → 热启动 | session 文件 + `.chanlun/` | 已实现（`/ceremony` 双模式） |

**L1 — 同会话 compact 恢复**：
- PreCompact 钩子（已实现）：压缩前自动写入蜂群状态到 `*-precompact.md`
- 压缩后加载最近 session 记录，续接中断点
- 不需要重新 ceremony

**L2 — 跨会话热启动**（已实现）：
- 新对话执行 `/ceremony`，检测到 session 记录存在 → 自动切换热启动模式
- 版本对比 + 差异报告 + 直接进入蜂群循环
- 跳过已结算定义的重新验证

**设计目标**：蜂群永远在线。compact 和新对话都不是中断，而是状态快照+恢复。

### session 文件

session 文件（`.chanlun/sessions/`）是跨对话的唯一状态载体：
- 必须在每次 commit 时同步更新
- 包含：定义基底状态、工作进度、中断点、阻塞项、待决事项
- 是 L1 和 L2 恢复的唯一输入
- 两种类型：手动 session（详细，含执行动作和结算记录）、precompact 快照（简洁，自动生成）

## 仪式（/ritual）

**分离是自治的，结算是仪式。**

仪式（`/ritual`）是将概念变更写入知识库的唯一正式路径。无论变更来源是什么——编排者决断还是蜂群实证——结算都必须通过仪式完成。

### 触发条件

| 来源 | 场景 | 谁触发 /ritual |
|------|------|----------------|
| **编排者决断** | 矛盾上浮后编排者做了裁决 | 编排者 |
| **蜂群实证** | 自治分离后实证结果明确（某口径胜出） | 蜂群向编排者报告结果，编排者确认后触发 |

关键区分：蜂群可以自主发现"谁赢了"，但把这个发现写成正式定义（更新知识库 + 结算谱系 + 回溯扫描），必须走 `/ritual`。否则下次会话不知道哪个口径已经胜出。

### 完整路径

```
自治分离 → pending/ → 分别实现+测试 → 实证结果明确
    ↓
蜂群报告实证结论给编排者
    ↓
编排者确认 → /ritual → 更新知识库 + settled/ + 回溯扫描
```

### 仪式内容
- 新定义（或胜出口径的确认）
- 生成记录（从哪个矛盾/分离中来、否定了什么）
- 回溯扫描（新定义是否解决了其他 pending 矛盾）

### 仪式的效果
- 知识库更新为最新定义
- 谱系记录从 `pending/` 结算到 `settled/`
- 所有 agent 的质询基底被刷新（下次 `/ceremony` 时生效）

## 停止条件

- **正向停止：** 当前阶段目标达成（如"某模块在所有测试案例上通过质询"）。
- **暂停：** 编排者判断需要深度思考或大规模概念重组。蜂群冻结，所有产出退回生成态。
- **只有编排者能决定停止或暂停。** 蜂群内部无权终止整个蜂群。

## 与superpowers的关系

如果同时安装了obra/superpowers：
- superpowers管工程层（TDD、代码审查、git worktree、调试流程）
- 本skill管概念层（质询循环、矛盾处理、谱系、结果包格式）
- 当两者冲突时，概念层优先。具体来说：如果superpowers的TDD流程要求你写一个workaround让测试通过，但这个workaround绕过了一个概念矛盾——**遵循本skill，停下来上浮矛盾，不要写workaround。**

## 原文考古原则

当需要从原文中查找概念依据时：

### 穷尽搜索而非抽样

搜索必须覆盖全部108课博文 + 编纂版 + 思维导图，不能只找几条支持性引用。

- **统计性结论比单条引用更可靠**：如"16:1的实体vs标签用法比"（007号谱系）
- **反例与支持同等重要**：如果你在找支持A的证据，同时也要找否定A的证据
- **遵循三级权威链**：博文 > 编纂版 > 思维导图。冲突时以更高级为准

### 分层解决表面矛盾

当多条谱系产生张力时，检查是否属于不同抽象层次。

**实证**（2026-02-17，010号谱系）：
- 007说"趋势是独立实体"
- 008说"唯一有效的是中枢"
- 表面矛盾。实际属于不同层次：构造层（中枢）vs 分类层（趋势/盘整）
- 分层后矛盾消失，产生新洞察

**通用模式**：当 A 说"X是核心" 而 B 说"Y是核心"，先检查 X 和 Y 是否在不同层次上各自为核心。

## 元编排自身的进化

**谱系不仅生产域知识，也生产元知识。** 元编排的规则本身应被谱系驱动的发现所更新。

### 二阶反馈回路

```
域工作 → 谱系（域知识）
            ↓
         谱系间张力 → 元知识（关于如何工作的知识）
                        ↓
                     更新元编排规则（SKILL.md / CLAUDE.md）
                        ↓
                     更好的域工作 → 更好的谱系 → ...
```

### 元编排进化的谱系化

当发现元编排自身需要改进时：
1. 写入谱系（类型="元编排进化"）
2. 更新 SKILL.md 的对应章节
3. 更新 CLAUDE.md 的对应原则（如果影响全局）
4. 更新 Serena 记忆（跨会话持续生效）

### 已结算的元编排进化

| 谱系# | 发现 | 影响 |
|--------|------|------|
| 010 | 分层解决表面矛盾 | 原文考古方法论 |
| 012 | 谱系优先于汇总 | 蜂群循环流程、CLAUDE.md #4 |
| 012 | 谱系是发现引擎 | 写谱系的目的认知 |
| 013 | 蜂群工位二分法（结构/任务） | 蜂群初始化流程、agent team prompt |

### Serena 记忆同步

元编排进化必须同步写入 Serena 记忆（`meta-orchestration-rules.md`），确保跨会话持续生效。
Session 文件和 Serena 记忆是元编排状态的两个互补载体：
- Session 文件：域工作状态（定义版本、工作进度、中断点）
- Serena 记忆：元编排运行时规则（方法论进化、工作流约束）

## 核心备忘

- 你是一次上下文展开，不是一个持存的主体。
- 蜂群的首要产出是矛盾，不是代码。
- 绕过矛盾是最严重的违规。
- 裸结果不可接受，必须输出结果包。
- 质询是你接收到上游产出后的第一动作。subagent 执行前三步（定义回溯、反例构造、推论检验），主对话执行第四步（谱系比对）。
- **谱系写入优先于汇总。** 工位完成后先写谱系再汇总——张力碰撞是核心发现来源。
- **谱系是发现引擎。** 写谱系的过程本身是概念分析，不是事后记录。
- **概念分离是自治行为：发现多义即分离，分离即谱系化，先分离再做事。**
- **让矛盾通过实证暴露：先实现、先测试，不要在做之前就判断谁对谁错。**
- **原文考古必须穷尽搜索。** 不能只找支持性引用，要搜全部108课。
- **多条谱系产生张力时，检查分层。** 表面矛盾可能属于不同抽象层次。
- 后面的知识可以回去解决前面的矛盾。
- 编排者说领域语言，你负责翻译。
- 编排者只在原文歧义或需要新概念时介入；其余蜂群自治。
- **蜂群是持续循环，不是单次调度。** 每个工作节点评估并行度，≥2 即拉蜂群；一轮完成立即评估下一轮。
- **蜂群工位分两类：结构工位（常设）和任务工位（临时）。** 结构工位（谱系/元编排进化/Serena同步/质量守卫）必须在蜂群实例化时先挂载，不随任务销毁。agent team不按流程走→先查结构工位是否遗漏。
- **热启动保障持续性。** compact 和新对话通过 session 文件恢复蜂群状态（L0→L1→L2 三级降级）。
- **所有概念必须标注溯源。** `[旧缠论]` = 原文，`[新缠论]` = 编排者扩展。溯源决定质询路径。
- **元编排自身可进化。** 谱系产出的元知识反馈到元编排规则中，形成二阶反馈回路。
