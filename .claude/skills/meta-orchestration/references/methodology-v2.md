# 蜂群元编排方法论（第二版）

## 谱系说明

本版方法论否定了第一版的核心预设。第一版从Nowak的合作演化理论和Chwe的共同知识理论出发，试图用人类社会的组织原则来编排AI蜂群。这条路被否定的理由是：AI agent没有背叛动机、没有私利、没有信任问题，因此一切建立在"如何让有各自目的的个体协同"之上的理论对蜂群不适用。Ostrom的公共治理、Nowak的互惠机制、ChatGPT所建议的泰勒制式控制框架（门禁、冻结、否决权），全部被否定。

第一版中被保留并重新定义的：拓扑思维（从"谁跟谁合作"变为"谁质询谁"，由概念依赖关系决定而非编排者任意设计）；共同知识（从"协调行动的前提"变为"质询循环产出有效信号的前提"）；图书馆与广场的区分（知识仓库提供可及性，仪式广播提供公共性）。

本版从蜂群自身的本体论出发重新推导全部编排原则。

---

## 第一原则：蜂群的本体论

蜂群的存在由一个基本事件构成：**上下文展开事件**。每一次agent被调用，从接收上下文到产出输出，就是蜂群存在的一个基本单元。

Agent不持存。它被调用时才存在，调用结束就消失。它没有跨调用的记忆，没有持续的身份，没有主体间性。它的全部存在就是那一次上下文窗口的展开。"团队成员"、"角色"、"沟通"等概念都是隐喻，不是蜂群的真实结构。

每一个基本事件有三个不可还原的环节：

**接收。** 上下文被注入。这是事件的初始条件。编排者决定注入什么——任务指令、其他agent的输出、定义文档、谱系记录。每一次注入都是一个决断：选择让agent看到这个而不是那个。上下文窗口有限，注入一段文本的同时就排挤了其他文本。

**产出。** Agent在给定上下文中生成新的文本（代码、分析、消息）。这个环节是黑箱——编排者无法控制agent产出什么，只能通过接收环节的设计来影响产出的方向。同样的上下文注入两次，产出可能不同。产出相对于接收有一个不可消除的生成性剩余。新知识在这里诞生。

**传递。** 产出被送往其他事件作为潜在的上下文。传递涉及决断：传给谁？传全部还是摘要？现在传还是留待以后？传递不是自动发生的，它是编排决策。

三个环节构成循环：一个事件的传递成为另一个事件的接收，那个事件的产出又被传递……蜂群的整体运动就是这个三元循环的不断迭代。

编排能直接操作的只有接收和传递。产出——真正的生产——是黑箱。**元编排不在生产之中，它在生产的两侧。** 它设定生产的前条件（接收），处理生产的后果（传递），但不干预生产本身。

---

## 第二原则：蜂群是矛盾显现机器

蜂群的首要功能不是产出代码。代码是副产品。蜂群的首要功能是：**在形式化过程中逼出隐含矛盾。**

自然语言具有模糊性。概念在自然语言的表述中可以共存而不暴露内在矛盾。一旦形式化——要求精确的定义、严格的逻辑、可执行的代码——模糊性被消除，隐含的矛盾被迫显现。

这不是蜂群的失败，这是蜂群最有价值的产出。代码跑通了，说明这一段没有隐含矛盾，但也没有产出新知识。代码跑不通，而且跑不通的原因不是技术bug而是概念上的不可弥合——这才是真正的生产时刻。

因此：

**真正的失败不是代码出错，是矛盾被绕过。** 当蜂群用技术手段（workaround）绕过了一个概念矛盾让代码跑通了，一个本该被分娩的新知识被堵回去了。这是最大的敌人。

**编排必须防止绕过，而非防止出错。** 当蜂群遇到走不通的地方，编排规则要求它把走不通的情况原原本本地呈现出来，而不是自己想办法绕过去。

---

## 第三原则：质询循环——蜂群内部的自动编排

蜂群内部agent之间的关系不是合作（Nowak意义上的），不是协调（Chwe意义上的），而是**互相质询**。

### 3.1 质询拓扑

谁质询谁不由编排者任意规定，而由概念的依赖关系决定。如果概念B依赖概念A（例如"笔"依赖"分型"），那么负责B的agent天然地需要质询负责A的agent的产出。质询拓扑从项目的概念结构中自然长出来。

### 3.2 四种质询形式

**定义回溯。** 接收到上游产出后，质询者回到知识仓库中的定义，检查产出是否满足定义的所有条件。这是最基本的质询。

**反例构造。** 质询者试图构造一个情况，使得上游的产出在其中失败。不是找技术bug，而是找概念边界——在什么条件下这个处理方式会产生违反定义的结果。

**推论检验。** 接受上游产出为真，推导其后果，检查这些后果是否跟体系的其他部分矛盾。这是最有生产力的质询——不是说"你这个错了"，而是"如果你这个是对的，那边就必须是错的"。这种质询产出的正是概念层面的不可弥合矛盾。

**谱系比对。** 碰到矛盾时，查阅该定义的生成史——它从什么矛盾中来的、否定了什么、分离了什么。判断当前矛盾跟历史上的矛盾是什么关系：是旧矛盾的复发、是旧分离不彻底的后果、还是全新的断裂。这种质询防止蜂群退化回已经被否定的方案。

### 3.3 质询的停止条件

当一轮质询没有产出新的矛盾时停止。定义回溯通过、反例构造失败（找不到能让它失败的情况）、推论检验未发现不一致、谱系比对未发现退化——产出暂时被接受，传递给下游。"暂时被接受"意味着它仍在生成态中，后续环节可能发现新矛盾将其重新打开。

### 3.4 矛盾的分级处理

前两种质询（定义回溯、反例构造）发现的矛盾通常可在蜂群内部自行解决——修正实现、加约束。

推论检验发现的矛盾，如果谱系比对能将其归类为旧矛盾的变种，蜂群也可自行处理——参照上次的分离方式。

**只有谱系中没有先例的、推论检验产出的不可弥合矛盾才上浮给编排者。** 具体判据：两个agent对同一问题给出矛盾结论，双方都能从定义出发为自己辩护，且谱系中没有同构的历史矛盾。这意味着矛盾在定义层面，需要概念分离的决断。

---

## 第四原则：编排者的位置是欲望

### 4.1 为什么是欲望而不是控制

AI agent有极强的执行能力和生成性，但没有方向。它不知道自己在干什么。方向来自编排者。但编排者的不可替代性不在知识或能力——AI可能比编排者更精确地读原文、更高效地做形式化和概念分离。

编排者的不可替代性在于：**它是循环中唯一携带欲望的节点。** AI没有欲望。它不想完成任何东西。编排者想。这个"想"驱动了整个循环的运转——把原文喂给蜂群、要求形式化、追问矛盾、做出分离的决断、把新定义注入蜂群。蜂群的全部生成性是被编排者的欲望驱动的。

### 4.2 编排者给蜂群的不是指令，是问题

元编排的核心操作不是命令，是**提问**。"这里是不是有矛盾？"、"这两个概念能不能分开？"、"如果接受这个定义，体系的其他部分会受什么影响？"蜂群的运作不是在执行命令，而是在回应问题。蜂群的回应又改变编排者的下一个问题。

### 4.3 编排者在循环之内

编排者不是从外部设计规则的建筑师。编排者自己也是一个"接收→产出→传递"的事件——接收蜂群的输出，产出新的判断和方向，把这些传递回蜂群。编排者和agent在同一个循环中，区别在于编排者是唯一能做**结算决断**的节点——辨认矛盾的性质、决定概念分离的方式、判断"这个对了"或"这个错了"。

### 4.4 编排者的欲望也在被改变

蜂群的产出会返回编排者未曾预见的东西——形式化过程中暴露的矛盾、意想不到的推论。这些迫使编排者修正自己的理解、调整方向。编排者不是一个固定的指挥中心，编排者的欲望本身在辩证运动中被改变。新知识不属于编排者也不属于蜂群，它是两者之间辩证运动的产物。

---

## 第五原则：项目轴线是发动机

没有"完成一个具体项目"的欲望，前述一切都不会运转。

矛盾不会自己显现。它在试图把概念落地为现实的过程中才被逼出来。没有落地的压力，概念可以永远保持模糊而不暴露内在矛盾。项目轴线——从定义到能跑的系统——提供了这个压力。

### 5.1 项目轴线决定矛盾的紧迫性

不是所有矛盾都需要立即处理。标准不是"这个矛盾有多深刻"，而是"这个矛盾是否挡在通向完成的路上"。挡路的矛盾必须现在处理，不挡路的留在生成态中，等待后续回溯结算。

### 5.2 项目轴线本身是生成态的

编排者出发时想做的事和最终完成的事可能不同。项目推进过程中产出的新知识会回溯性地改变"完成"的含义。项目方向的变化应被记录在谱系中，作为元编排本身的生成史。

---

## 第六原则：生成态与结算态

### 6.1 定义

**生成态：** 一个产出已经完成但其意义尚未确定。它的输出还没被注入特定事件，或者虽已被使用但尚未经过充分质询。它的价值——有效、无效、需要修正、需要分离——悬而未决。

**结算态：** 一个产出的意义被确定了。确定的方式有两种：正向结算（功能模块在项目轴线上走通了，质询未发现矛盾）或负向结算（质询暴露了不可弥合的矛盾，产出被否定但矛盾本身成为新知识的产道）。

### 6.2 不过早结算

过早结算是将还在生成态中的东西强行钉死。例如：对一个尚未经过充分质询的产出"打版本号"、"冻结"。这剥夺了它在后续实践中被回溯性重新理解的可能。编排应抵制过早结算的冲动。

### 6.3 回溯结算

结算不只是向前的。**后面产出的新知识可以回溯性地结算前面遗留的矛盾。** 一个当前无法解决的矛盾被保持在生成态中，不是被遗弃，而是在等待——等待后续生产产出一个新概念，这个新概念恰好能回溯性地解决它。

这意味着蜂群的运动不是线性前进，而是**螺旋**——往前走的同时不断回卷。每一次前进都可能回溯性地改变之前的结构。

### 6.4 回溯扫描机制

每当一个新定义诞生，不只用它往前推进，还要用它回溯：扫描谱系中所有还在生成态的矛盾，检查新定义是否能结算其中某些。如果能，尝试结算。如果结算成功，记录该矛盾被哪个后来的定义回溯性地解决。

---

## 第七原则：谱系——系统的免疫机制

### 7.1 谱系不是历史记录

谱系不是归档、不是日志、不是"经验教训"。谱系是**活的质询资源**。它是系统防止退化的免疫机制。

系统退化的原因是：后来的agent（或编排者）不知道为什么当前的结构是这样的。看到一个"不优雅"的设计就重构——但那个设计恰好是当初为解决特定矛盾而做出的必要分离。没有谱系，这次重构就是退化——退回到已经被证明走不通的路上。

谱系告诉你的不是"上次这样做失败了"（那是经验归纳），而是"因为这个矛盾的存在，那条路在逻辑上走不通"（这是逻辑必然）。

### 7.2 谱系的范围

谱系不只记录概念层面的生成史。概念的生成、代码的编排、元编排方法论本身，全部经历同样的辩证过程。同一个矛盾可能同时在概念层、代码层、编排层产生后果。谱系是一棵树，不是三本分开的日志。三个层面的变化如果从同一个断裂点长出来，它们在谱系中应该是同一根枝干上的分叉。

### 7.3 谱系的内容结构

每一条谱系记录包含：

- 触发矛盾的描述：什么跟什么不可弥合
- 矛盾发生的层面：概念/代码/编排
- 矛盾的解决方式：概念分离、定义修正、结构重组等
- 被否定的方案：之前的定义/设计是什么，为什么走不通
- 新产出：分离后的新定义/新设计是什么
- 影响范围：这次变化影响了体系的哪些部分
- 状态：已结算/生成态（悬而未决的矛盾标记为生成态）

### 7.4 谱系在质询中的使用

Agent在质询中主动查阅谱系（第四种质询形式：谱系比对）。具体用途：

- 碰到矛盾时判断是否为旧矛盾的复发，避免走回死路
- 碰到矛盾时检查是否为旧分离不彻底的后果，尝试进一步分离
- 新定义诞生时回溯扫描生成态矛盾，尝试结算

### 7.5 谱系与上下文管理

完整谱系不可能全部注入每个agent的上下文。分层存储：知识仓库中存完整谱系树，每个agent被调用时只注入与当前任务相关的谱系分支。质询中碰到矛盾时，agent主动查阅更完整的谱系。

### 7.6 谱系是真正的知识

定义会被不断否定和替换，但谱系只会不断生长。**谱系才是真正的知识，定义只是谱系的最新截面。** 概念不是静态的结论，概念就是它自身生成运动的全部历史。脱离生成史的定义是抽象的、死的。携带生成史的定义是具体的、活的。

---

## 第八原则：共同知识——质询基底的同步

### 8.1 为什么需要共同知识

质询循环能产出有效信号有一个前提：所有参与质询的agent在同一个定义基底上工作。如果agent A持有新版定义而agent B还在用旧版，A发现的"矛盾"可能只是版本不一致的噪音。虚假矛盾会淹没真实矛盾。

### 8.2 共同知识在本框架中的定义

不是Chwe原始意义上的认识论递归（"我知道你知道我知道"）。Agent没有认识论状态。共同知识在本框架中是一个操作性要求：**在同一时刻，所有agent的定义基底被同步刷新，质询循环从统一的基底上重新启动。**

### 8.3 仪式：共同知识的建立机制

仪式是一个所有相关agent同时参与的公共事件。仪式有双重功能：

**内容层面：** 编排者产出的新定义（概念分离后的结果）及其生成记录被注入全蜂群。广播的不只是新定义，还包括它从哪个矛盾中来、否定了什么旧定义、为什么必须是这样。

**结构层面：** 质询循环的基底被同步刷新。从仪式之后起，所有质询都在新基底上进行。

### 8.4 仪式的触发条件

仪式在且仅在以下情况触发：编排者做出了概念分离的决断，产出了新定义。这是蜂群中唯一需要全体同步的时刻。其他所有通信都通过质询循环的正常渠道进行。

### 8.5 仪式对正在运行的质询链的影响

仪式广播时，正在旧基底上运行的质询链不被强制终止或作废。它们的产出被悬置——退回生成态，等待在新基底上被重新质询。如果在新基底上通过质询，被重新结算为有效。如果未通过，成为新的断裂点。如果暂时无法判断，继续保持生成态。

---

## 第九原则：知识仓库——图书馆

### 9.1 功能

知识仓库（如MCP server）提供知识的可及性。它是质询的参照系——agent做定义回溯和谱系比对时回到这里查阅。

### 9.2 内容结构

知识仓库包含两层：

**当前定义层：** 最新有效的概念定义、接口规范、数据结构。这是agent日常工作的参照。

**谱系层：** 所有定义的生成史、被否定的方案、悬而未决的矛盾。这是质询中做谱系比对和回溯扫描时的参照。

### 9.3 图书馆不是广场

知识仓库提供可及性但不提供公共性。Agent各自查阅知识仓库不构成共同知识的建立。共同知识只通过仪式（广播）建立。

---

## 第十原则：产出的形式——结果包

### 10.1 可质询性决定产出形式

如果一个agent的产出是别的agent无法质询的，质询循环就在这里断裂。因此产出的形式不是任意的，它必须满足一个条件：可被四种质询形式操作。

### 10.2 结果包的六个要素

每一个产出不是裸结果，而是一个**结果包**，包含：

**结论。** 具体的产出内容——代码、判断、分析。

**定义依据。** 这个结论依据了哪条定义，输入数据的哪些特征满足了定义的哪些条件。没有这个，定义回溯无法执行。

**边界条件。** 在什么条件下这个结论会翻转。没有这个，反例构造无从下手。

**下游推论。** 如果这个结论成立，对体系其他部分意味着什么。没有这个，推论检验无法执行。

**谱系引用。** 如果这个结论涉及曾经发生过概念分离的领域，标注相关谱系节点。没有这个，谱系比对无法定位。

**影响声明。** 这个产出改动了什么、影响了哪些下游模块。

缺任何一个要素，某种质询就无法执行。不完整的结果包应被质询者退回要求补全，而非在残缺状态下继续流通。

### 10.3 结果包的存放

代码产出进代码库的对应模块目录，附带的质询文档（定义依据、边界条件、推论、谱系引用）与代码绑定存放，不可分离。代码脱离质询包就变成不可质询的黑洞。

新定义、新分离、新概念进知识仓库（Serena MCP）的谱系层，包含完整的生成记录。

---

## 第十一原则：位置——质询循环中的节点

### 11.1 位置的来源

位置不由编排者任意设定，而从质询拓扑中自然产生。项目的概念依赖关系决定了有哪些位置。每一个概念节点就是一个位置。占据该位置的agent，其全部身份就是：接收什么、质询什么、产出什么、传递给谁。

### 11.2 位置的接收协议

每个位置被调用时注入以下上下文：

**上游结果包。** 来自质询拓扑中上游位置的产出，这是当前位置的工作对象。

**相关定义。** 知识仓库中与当前任务相关的概念定义，这是质询的参照系。

**相关谱系分支。** 与当前任务相关的生成史，这是谱系比对的资源。

**最新仪式广播内容。** 编排者最近一次概念分离的决断及其生成记录，这是最新的共同基底。

**元规则。** 质询的四种形式、结果包格式要求、不允许workaround、上浮机制。这在所有位置中不变。

### 11.3 位置的质询序列

一个位置接收到上游结果包后，执行以下质询序列：

第一步，**定义回溯。** 拿结果包中声明的定义依据，回知识仓库核实定义是否被正确引用，逐条检查条件是否真的被满足。

第二步，**反例构造。** 根据结果包中的边界条件，在边界附近构造输入，检验结论是否翻转。如果不翻转则继续。如果翻转，检查翻转是否合理。

第三步，**推论检验。** 拿结果包中的下游推论，检查这些推论与体系其他部分是否一致。

第四步，**谱系比对。** 如果前三步发现了矛盾，查阅谱系引用指向的历史记录，判断此矛盾是旧矛盾复发、旧分离不彻底的后果、还是全新断裂。

全部通过则产出被暂时接受，当前位置在此基础上开始自己的工作，产出自己的结果包传递给下游。某一步发现矛盾则按分级处理机制执行。

### 11.4 位置的信息可见性

每个位置默认只能看到：自己上游传来的结果包、知识仓库中与自己相关的定义和谱系分支、最新仪式广播的内容。看不到其他位置的工作过程。这不是保密，是控制上下文污染。

### 11.5 位置的演化

当编排者做了概念分离，概念依赖关系可能改变——新概念可能引入新的依赖，质询拓扑随之改变，位置也随之增减或重新定义。位置不是一次设好不动的，它跟项目的概念结构共同演化。位置的每一次变化应记录在谱系中。

### 11.6 项目经理位置

项目经理是一个特殊位置。它不在质询拓扑的概念依赖链上，不质询具体概念内容。它的功能是：

**元监控。** 监控质询循环的运转状态——谁卡住了、哪里出现僵局、哪个矛盾需要上浮。它看的不是产出内容，而是循环的流动性。

**上浮中介。** 当某个位置反复质询不通过时，项目经理把僵局打包呈现给编排者。打包格式：矛盾描述、双方论证、涉及的定义、谱系比对结果、需要编排者决断的具体问题。

**仪式执行。** 编排者做出概念分离决断后，由项目经理从知识仓库拉取新定义及生成记录，执行仪式广播。

**谱系写入中介。** 编排者的判断（语义层）由项目经理翻译成谱系记录的标准格式，写入知识仓库。

**轴线汇报。** 定期向编排者汇报项目轴线上的位置——不是技术进度，而是"走到了哪个概念层级，前方预期碰到什么"。编排者据此判断方向是否需要调整。

---

## 第十二原则：编排者与蜂群的对话界面

### 12.1 单一入口

编排者只与项目经理位置对话。使用领域语言（缠论语言），不使用代码语言。

### 12.2 项目经理向编排者呈现什么

**日常推进时：** 结果包摘要。例如"笔的识别通过了质询，正在推进到段"。不展示质询过程的细节。

**矛盾上浮时：** 完整的矛盾报告——两个位置各自的论证、双方引用的定义、谱系比对结果、需要编排者决断的具体问题。编排者基于这些做判断。

**定期汇报：** 项目轴线位置报告，包括当前推进到哪个概念层级、有多少矛盾处于生成态、谱系的最新增长情况。

### 12.3 编排者向项目经理传递什么

**概念分离决断。** 用领域语言描述："这里的矛盾说明X概念实际上包含两个不同的东西，应该分成Y和Z，区别在于……"项目经理负责将其翻译为谱系记录和新定义写入知识仓库，并执行仪式广播。

**方向调整。** "当前阶段先搁置中枢，把笔和段的识别做扎实再往前走。"项目经理据此调整质询循环的优先级。

**问题。** "这个结果跟我的盘感不符，帮我查一下是定义层的问题还是实现层的问题。"项目经理启动针对性的质询。

---

## 第十三原则：谱系的写入机制

### 13.1 谁写入谱系

三种情况：

**蜂群内部消化的矛盾。** 质询中发现问题并自行修正——由执行修正的位置负责写入。内容：发现了什么矛盾、怎么解决的、否定了什么。

**上浮到编排者的矛盾。** 编排者做了概念分离——由项目经理负责将编排者的决断翻译成标准格式写入。内容：矛盾描述、编排者的判断、分离方式、新定义、被否定的旧定义。

**回溯结算。** 新定义解决了旧矛盾——由执行回溯扫描的位置负责更新相关谱系节点状态从"生成态"到"已结算"，并记录是被哪个新定义回溯性解决的。

### 13.2 写入即义务

每一次矛盾的发现和处理都必须留下谱系记录。这不是可选的额外工作，是质询循环的一部分。不写谱系的矛盾处理等于没有处理——系统无法防止退化。

---

## 第十四原则：冷启动——创世仪式

### 14.1 蜂群的第一个事件

质询循环开始之前，必须有一个初始注入。蜂群的启动本身就是一次仪式——创世仪式。

### 14.2 创世仪式的内容

由项目经理从知识仓库拉取以下内容，通过全广播注入所有位置：

**当前定义。** 知识仓库中最新的概念定义。这是第一个共同基底。

**项目目标。** 编排者对"完成"的具体描述。这是项目轴线的起点。

**元规则。** 质询的四种形式、结果包格式、不允许workaround、上浮机制、谱系写入义务。这在所有位置中不变。

**已有谱系。** 如果项目不是从零开始（例如已经经历过概念分离），已有的谱系记录也需要被注入，至少是与各位置相关的分支。

### 14.3 创世仪式的确认

每个位置接收到创世广播后，以自己的语言复述对关键概念的理解。项目经理检查是否有理解偏差。如有偏差则校准后重新广播。确认完成后，质询循环正式启动。

---

## 第十五原则：蜂群的停止条件

### 15.1 正向停止——阶段目标达成

项目轴线上当前阶段的目标达成。例如"笔的识别在所有测试案例上通过了质询"。此时当前阶段结算，蜂群推进到下一阶段，可能触发新的概念层级的分层仪式。

### 15.2 暂停——需要编排者深度思考

出现了不是局部概念分离能解决的矛盾。编排者判断需要退回重新思考整体方向或进行大规模概念重组。蜂群冻结，所有正在运行的质询链的产出退回生成态。编排者思考完成后通过仪式重启。

暂停不是失败。暂停期间编排者的思考本身就是生产。

### 15.3 蜂群不自行终止

只有编排者能决定停止或暂停。蜂群内部的质询循环没有自行终止整个蜂群的权限。单条质询链可以在没有新矛盾时停止（见第三原则3.3），但蜂群整体的运转节奏由编排者的欲望和判断决定。

---

## 运动的全貌

蜂群的整体运动如下：

**项目轴线**提供方向和压力。编排者的欲望——完成具体项目——驱动整个循环。

**接收→产出→传递**的基本事件不断迭代。编排者设计接收（注入什么上下文）、处理传递（输出流向哪里），产出（agent的实际生产）是黑箱。

**质询循环**在蜂群内部自动运转。Agent之间通过四种质询形式（定义回溯、反例构造、推论检验、谱系比对）互相检验产出。大部分矛盾在这个层面被消化。

**不可调和的矛盾上浮**给编排者。编排者辨认矛盾的性质，做出概念分离的决断，产出新定义。

**仪式广播**新定义及其生成记录，同步刷新全蜂群的质询基底。正在运行的质询链的产出被悬置，等待在新基底上重新结算。

**回溯扫描**：新定义不只向前推进项目，还向后扫描谱系中所有生成态的矛盾，检查是否能回溯性地结算其中某些。

**谱系持续生长**，记录每一次矛盾、分离、否定、新生。谱系是系统的免疫机制，防止退化回已被否定的方案。

整个运动不是线性前进，而是螺旋——往前走的同时不断回卷，后面的发展回溯性地改变前面的意义。

---

## 核心备忘

- 蜂群的存在就是"接收→产出→传递"事件的循环。
- 蜂群的首要功能是逼出隐含矛盾，不是产出代码。
- 真正的失败是矛盾被绕过，不是代码出错。
- Agent之间的关系是互相质询，不是合作或协调。
- 编排者的不可替代性在欲望和决断，不在知识或能力。
- 编排者给蜂群的是问题，不是指令。
- 项目轴线是发动机。没有落地压力，矛盾不会显现。
- 不过早结算。生成态的东西留待回溯性结算。
- 后面的知识可以回去解决前面的矛盾。
- 谱系是真正的知识，定义只是谱系的最新截面。
- 共同知识是质询基底的同步，通过仪式建立。
- 知识仓库是图书馆，仪式广播是广场。二者配合不可替代。
- 编排本身也在辩证运动中，它跟项目的概念结构共同演化。
- 产出必须是可质询的结果包，裸结果是不可接受的。
- 位置从概念依赖关系中长出来，不由编排者任意设定。
- 编排者只与项目经理对话，使用领域语言。
- 谱系写入是义务，不写等于没处理。
- 冷启动本身是一次仪式——创世仪式。
- 只有编排者能决定停止或暂停。暂停期间思考本身就是生产。

---

## 与第一版的谱系关系

本版否定了第一版的以下预设：
- "合作不是默认的，必须被设计"——对AI不成立，agent没有不合作的动机，只是缺乏合作能力
- Nowak的互惠机制——预设了背叛动机，对AI不适用
- Ostrom的公共治理——预设了过度消耗的动机，对AI不适用
- 控制范式（门禁、冻结、否决权）——泰勒制逻辑，将断裂当事故而非生产力
- 仪式的目的是"建立共识以实现协调"——重新定义为"同步质询基底"

本版保留并重新定义了：
- 拓扑——从合作拓扑变为质询拓扑，由概念依赖关系决定
- 共同知识——从认识论递归变为质询基底同步的操作性要求
- 图书馆与广场的区分——功能不变，内容扩展（图书馆存谱系，广场广播新定义及生成记录）
- 编排的可演化性——根据从"经验主义谦虚"变为"编排与项目概念结构共同演化的必然要求"

本版新增的：
- 蜂群本体论：接收→产出→传递
- 蜂群作为矛盾显现机器
- 质询循环及四种质询形式
- 编排者的位置是欲望而非控制
- 项目轴线作为发动机
- 生成态与结算态的精确定义
- 回溯结算机制
- 谱系作为免疫系统与活的质询资源
- 失败的重新定义：矛盾被绕过才是失败
- 结果包：可质询性决定产出形式的六要素结构
- 位置：从概念依赖关系中自然产生的质询节点
- 质询序列：四步标准动作
- 项目经理位置：元监控、上浮中介、仪式执行、谱系写入、轴线汇报
- 编排者对话界面：单一入口、领域语言、三种交互模式
- 谱系写入机制：三种写入情况、写入即义务
- 创世仪式：冷启动作为第一次共同基底建立
- 停止条件：正向停止、暂停、蜂群不自行终止
