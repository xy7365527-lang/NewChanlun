# /ritual — 定义广播仪式

当编排者做出概念分离决断、产出新定义后执行。刷新所有agent的质询基底。

<!-- v3变更：/ritual 是完整仪式，用于概念层定义变更。
工程规格的更新由lead自主执行小仪式，不走/ritual。
区别：概念定义变更需要编排者决断 → /ritual；
工程规格补充lead有权自主处理 → lead直接写入并通知。 -->

## 用法

```
/ritual [新定义描述]
```

编排者做出概念层决断后调用。

## 执行步骤

1. **写入新定义** — 将编排者的决断翻译为标准格式，写入 `.chanlun/definitions/` 目录
2. **写入谱系** — 在 `.chanlun/genealogy/` 中记录这次概念分离：
   - 从哪个矛盾中来
   - 否定了什么旧定义
   - 新定义是什么
   - 分离的逻辑必然性（为什么必须这样分，不是"我觉得这样好"）
   - 标注为"概念层结算——编排者决断"
3. **回溯扫描** — 检查所有生成态矛盾：
   - 新定义是否解决了某些旧矛盾？
   - 如果能解决，执行回溯结算，更新谱系状态
   - 如果提供了新理解但尚不能完全解决，记录新理解但保持生成态
4. **基底刷新通知** — 通过SendMessage通知所有teammates，输出变更摘要：
   - 新增/修改了哪些定义
   - 否定了哪些旧定义
   - 回溯结算了哪些矛盾
   - 哪些正在进行的工作需要在新基底上重新质询

## 输出格式

```markdown
## 仪式完成（概念层）

### 新定义
- [定义名]：[内容]
- 来源矛盾：[GEN-XXX]

### 被否定的旧定义
- [旧定义名]：[内容]
- 否定原因：[逻辑必然性说明]

### 回溯结算
- [GEN-XXX]：已结算（被新定义 [名称] 解决）
- [GEN-YYY]：更新理解但保持生成态

### 基底刷新
以下工作的产出已退回生成态，需要在新基底上重新质询：
- [列出受影响的模块/任务]
```

## 小仪式（lead自主，不走/ritual）

当lead做出工程层决断时，不需要调用/ritual。lead直接：
1. 将工程规格更新写入 `.chanlun/definitions/`（不修改概念定义部分）
2. 将决断记录写入 `.chanlun/genealogy/`，标注"工程层结算——lead自主"
3. 通过SendMessage通知受影响的teammates
4. 不触发全局回溯扫描

## 注意

- /ritual（完整仪式）只有在编排者做出概念层决断后才能触发
- 工程规格更新由lead自主执行小仪式，不需要编排者确认
- 被退回生成态的产出不是被删除，而是等待在新基底上重新验证
- 判断标准：改的是概念定义本身 → /ritual；补的是工程规格 → 小仪式
